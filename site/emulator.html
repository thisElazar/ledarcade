<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wonder Cabinet - Emulator</title>
<link rel="stylesheet" href="shared.css">
<style>
.pyodide-lab {
  max-width: 700px;
  margin: 0 auto;
  padding: 0 24px 60px;
  text-align: center;
}
.pyodide-lab h2 {
  font-size: 13px;
  font-weight: 400;
  letter-spacing: 0.3em;
  color: #c8a86e;
  margin-bottom: 6px;
}
.pyodide-lab .lab-subtitle {
  font-size: 13px;
  color: #6a6254;
  margin-bottom: 24px;
}
.lab-status {
  font-size: 11px;
  color: #4a4238;
  letter-spacing: 0.05em;
  margin-bottom: 12px;
  display: block;
}
.lab-status.ready { color: #50c8a0; }
.lab-status.loading { color: #c8a86e; }
.lab-status.error { color: #ff6464; }
.lab-display {
  display: inline-block;
  background: linear-gradient(145deg, #151517, #101012);
  border-radius: 12px;
  padding: 14px;
  box-shadow: 0 8px 30px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.04);
  position: relative;
  margin-bottom: 16px;
  outline: none;
}
.lab-display .canvas-wrap {
  position: relative;
  width: min(400px, 60vw);
  aspect-ratio: 1;
}
.lab-display .canvas-wrap canvas.led {
  width: 100%;
  height: 100%;
  image-rendering: pixelated;
  display: block;
  border-radius: 4px;
}
.lab-display .canvas-wrap canvas.glow {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  image-rendering: pixelated;
  filter: blur(4px) brightness(1.4);
  opacity: 0.35;
  pointer-events: none;
}
.lab-display .click-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.6);
  border-radius: 4px;
  cursor: pointer;
  z-index: 10;
  transition: opacity 0.3s ease;
}
.lab-display .click-overlay span {
  font-size: 14px;
  letter-spacing: 0.15em;
  color: #c8a86e;
  text-shadow: 0 0 10px rgba(200,168,110,0.4);
}
.lab-fps {
  font-size: 11px;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
  color: #4a4238;
  margin-top: 8px;
}
.lab-keys {
  font-size: 11px;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
  color: #4a4238;
  margin-top: 6px;
}
.lab-notes {
  font-size: 11px;
  color: #8a8274;
  margin-top: 20px;
  text-align: left;
  max-width: 420px;
  display: inline-block;
  line-height: 1.6;
  background: #1a1814;
  border: 1px solid #3a3530;
  border-radius: 6px;
  padding: 12px 16px;
}
.lab-notes summary {
  cursor: pointer;
  color: #b0a898;
  letter-spacing: 0.05em;
  font-weight: 600;
  font-size: 12px;
}
.lab-notes summary:hover { color: #d0c8b8; }
.lab-notes p {
  margin: 8px 0 4px;
  color: #6a6254;
}
.lab-notes ul {
  margin: 6px 0 0;
  padding-left: 18px;
}
.lab-notes li { margin-bottom: 2px; }
.lab-notes .cat { color: #a09080; }

/* Touch controls — hidden on desktop, shown on touch devices */
.touch-controls {
  display: none;
  justify-content: center;
  align-items: center;
  gap: 24px;
  width: 100%;
  max-width: 420px;
  margin: 12px auto 0;
  padding: 0 8px;
  box-sizing: border-box;
  user-select: none;
  -webkit-user-select: none;
  touch-action: none;
}
.touch-device .touch-controls { display: flex; }
.touch-device #emuKeys { display: none; }
.touch-device .click-overlay span::after {
  content: ' (TAP)';
}

/* Action buttons (one on each side of joystick) */
.touch-btn {
  width: 62px;
  height: 62px;
  border-radius: 50%;
  border: 2px solid rgba(200, 168, 110, 0.3);
  background: rgba(30, 30, 34, 0.85);
  color: #c8a86e;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
  font-size: 20px;
  font-weight: 700;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  outline: none;
  -webkit-tap-highlight-color: transparent;
  flex-shrink: 0;
}
.touch-btn:active, .touch-btn.pressed {
  background: rgba(200, 168, 110, 0.25);
  border-color: rgba(200, 168, 110, 0.6);
  transform: scale(0.93);
}

/* Joystick */
.touch-joystick {
  touch-action: none;
  flex-shrink: 0;
}
.joystick-base {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: rgba(30, 30, 34, 0.85);
  border: 2px solid rgba(200, 168, 110, 0.25);
  position: relative;
  touch-action: none;
}
.joystick-knob {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: radial-gradient(circle at 40% 38%, rgba(200, 168, 110, 0.5), rgba(200, 168, 110, 0.2));
  border: 1px solid rgba(200, 168, 110, 0.4);
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: none;
  pointer-events: none;
}
.joystick-knob.idle {
  transition: transform 0.15s ease-out;
}

/* Escape (back) button */
.touch-esc {
  display: none;
  position: absolute;
  top: 4px;
  right: 4px;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: 1px solid rgba(200, 168, 110, 0.2);
  background: rgba(0, 0, 0, 0.6);
  color: #c8a86e;
  font-size: 16px;
  line-height: 32px;
  text-align: center;
  z-index: 11;
  touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
  outline: none;
  cursor: pointer;
}
.touch-device .touch-esc { display: block; }
.touch-esc:active {
  background: rgba(200, 168, 110, 0.25);
}

@media (pointer: coarse) {
  .touch-controls { display: flex; }
  #emuKeys { display: none; }
  .click-overlay span::after { content: ' (TAP)'; }
  .touch-esc { display: block; }
}

/* Notes form */
.notes-section {
  max-width: 480px;
  margin: 48px auto 0;
  padding: 0 24px 60px;
}
.notes-section h2 {
  text-align: center;
  font-size: 13px;
  font-weight: 400;
  letter-spacing: 0.3em;
  color: #c8a86e;
  margin-bottom: 6px;
}
.notes-subtitle {
  text-align: center;
  font-size: 13px;
  color: #6a6254;
  margin-bottom: 24px;
}
.notes-form {
  display: flex;
  flex-direction: column;
  gap: 16px;
}
.notes-row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
.notes-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
}
.notes-group label {
  font-size: 10px;
  letter-spacing: 0.2em;
  color: #9a9284;
  text-transform: uppercase;
}
.notes-group input[type="text"],
.notes-group input[type="email"],
.notes-group textarea {
  background: rgba(255,255,255,0.04);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 6px;
  padding: 10px 12px;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
  font-size: 13px;
  color: #d8d0c4;
  outline: none;
  transition: border-color 0.2s;
}
.notes-group input:focus,
.notes-group textarea:focus {
  border-color: rgba(200, 168, 110, 0.5);
}
.notes-group textarea {
  min-height: 80px;
  resize: vertical;
}
.notes-btn {
  background: rgba(200, 168, 110, 0.15);
  border: 1px solid rgba(200, 168, 110, 0.3);
  border-radius: 6px;
  padding: 12px 24px;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
  font-size: 12px;
  letter-spacing: 0.15em;
  color: #c8a86e;
  cursor: pointer;
  transition: all 0.2s;
}
.notes-btn:hover {
  background: rgba(200, 168, 110, 0.25);
  border-color: rgba(200, 168, 110, 0.5);
}
@media (max-width: 500px) {
  .notes-row { grid-template-columns: 1fr; }
}
</style>
</head>
<body>

<nav class="site-nav">
  <a class="nav-brand" href="index.html">WONDER CABINET</a>
  <a href="emulator.html" class="active">EMULATOR</a>
  <a href="guide.html">FIELD GUIDE</a>
  <a href="history.html">HISTORY</a>

  <a href="order.html">ORDER</a>
</nav>

<header>
  <h1>WONDER CABINET</h1>
  <p class="tagline">A cabinet of electronic curiosities</p>
</header>

<section class="pyodide-lab" id="pyodideLab">
  <h2>EMULATOR</h2>
  <p class="lab-subtitle">
    The full arcade running in your browser &mdash; Python source via Pyodide
  </p>

  <span class="lab-status loading" id="pyStatus">loading runtime...</span>

  <div class="lab-display" id="emuFrame" tabindex="0">
    <div class="canvas-wrap">
      <canvas class="glow" id="pyGlowCanvas" width="64" height="64"></canvas>
      <canvas class="led" id="pyLedCanvas" width="640" height="640"></canvas>
      <div class="click-overlay" id="emuClickOverlay"><span>CLICK TO START</span></div>
    </div>
    <button class="touch-esc" id="btnEsc">&#x2190;</button>
  </div>

  <div class="touch-controls" id="touchControls">
    <button class="touch-btn" id="btnL">GO</button>
    <div class="touch-joystick" id="touchJoystick">
      <div class="joystick-base" id="joystickBase">
        <div class="joystick-knob idle" id="joystickKnob"></div>
      </div>
    </div>
    <button class="touch-btn" id="btnR">GO</button>
  </div>

  <div class="lab-fps" id="pyFps"></div>
  <div class="lab-keys" id="emuKeys">Arrows: navigate &middot; Space: select &middot; Z: alt button &middot; Esc: back to menu</div>

  <div class="lab-notes">
    <details open>
      <summary>Arcade-only items</summary>
      <p>These items need image assets or dynamic loading unavailable in the browser.</p>
      <ul>
        <li><span class="cat">SPRITES</span> &mdash; GIF/PNG sprite animations</li>
        <li><span class="cat">SUPERHEROES</span> &mdash; GIF sprite animations</li>
        <li><span class="cat">GALLERY</span> &mdash; 3D galleries with image assets</li>
        <li><span class="cat">SCIENCE</span>: Earth &mdash; globe texture</li>
        <li><span class="cat">UTILITY</span>: Info, Update &mdash; system access</li>
      </ul>
    </details>
  </div>
</section>

<section class="notes-section">
  <h2>LEAVE A NOTE</h2>
  <p class="notes-subtitle">Bug reports, game requests, or just say hi</p>
  <form class="notes-form" action="submit-notes.php" method="POST">
    <input type="hidden" name="page" value="Emulator">
    <div class="notes-row">
      <div class="notes-group">
        <label for="note-name">Name</label>
        <input type="text" id="note-name" name="name" required>
      </div>
      <div class="notes-group">
        <label for="note-email">Email</label>
        <input type="email" id="note-email" name="email" required>
      </div>
    </div>
    <div class="notes-group">
      <label for="note-text">Note</label>
      <textarea id="note-text" name="note" required placeholder="What's on your mind..."></textarea>
    </div>
    <button type="submit" class="notes-btn">SEND NOTE</button>
  </form>
</section>

<footer>
  Programmed with AI, Designed &amp; Curated by Hand
</footer>

<script src="shared.js"></script>
<script>
(async function emulator() {
  const pyStatusEl = document.getElementById('pyStatus');
  const pyFpsEl = document.getElementById('pyFps');
  const pyLedCanvas = document.getElementById('pyLedCanvas');
  const pyGlowCanvas = document.getElementById('pyGlowCanvas');
  const emuFrame = document.getElementById('emuFrame');
  const emuOverlay = document.getElementById('emuClickOverlay');

  const GITHUB_RAW = 'https://raw.githubusercontent.com/thisElazar/ledarcade/main/';

  const pyRenderer = new LEDRenderer(pyLedCanvas, pyGlowCanvas);
  const pyDisplay = new Display();

  let catalog = null;
  let pyodide = null;
  let emuState = 'init';
  let hasFocus = false;
  const loadedModules = new Set();
  let paintingAtlasLoaded = false;
  let flagsAtlasLoaded = false;
  let signsAtlasLoaded = false;
  let galleryAtlasLoaded = false;
  let haeckelAtlasLoaded = false;
  let audubonAtlasLoaded = false;
  let merianAtlasLoaded = false;
  let redouteAtlasLoaded = false;
  let sebaAtlasLoaded = false;
  let gouldAtlasLoaded = false;

  function setStatus(text, cls) {
    pyStatusEl.textContent = text;
    pyStatusEl.className = 'lab-status ' + cls;
  }

  emuFrame.addEventListener('focus', () => { hasFocus = true; emuOverlay.style.display = 'none'; });
  emuFrame.addEventListener('blur', () => {
    hasFocus = false;
    for (const k in keys) keys[k] = false;
    for (const k in prevKeys) prevKeys[k] = false;
  });
  emuOverlay.addEventListener('click', (e) => { e.stopPropagation(); emuFrame.focus(); });
  emuOverlay.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); emuFrame.focus(); }, { passive: false });

  const keys = {};
  const prevKeys = {};
  let escapePressed = false;
  document.addEventListener('keydown', (e) => {
    if (!hasFocus) return;
    const k = e.key;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' ','z','Z'].includes(k)) {
      e.preventDefault();
      keys[k.toLowerCase()] = true;
    }
    if (k === 'Escape') {
      e.preventDefault();
      escapePressed = true;
    }
  });
  document.addEventListener('keyup', (e) => {
    const k = e.key;
    keys[k.toLowerCase()] = false;
  });

  // --- Touch controls ---
  const isTouchDevice = ('ontouchstart' in window || navigator.maxTouchPoints > 0);
  if (isTouchDevice) {
    document.body.classList.add('touch-device');
  }

  const joystickBase = document.getElementById('joystickBase');
  const joystickKnob = document.getElementById('joystickKnob');
  const btnL = document.getElementById('btnL');
  const btnR = document.getElementById('btnR');
  const btnEsc = document.getElementById('btnEsc');

  let joystickTouchId = null;

  // ── Smoothed joystick state ──
  const DEAD_ZONE = 0.18;        // 18% radius dead zone
  const EMA_ALPHA = 0.25;        // smoothing factor (lower = smoother)
  const HYSTERESIS_DEG = 15;     // degrees of "stickiness" per direction
  const DIR_COOLDOWN_MS = 80;    // min ms between direction changes
  let smoothX = 0, smoothY = 0;  // EMA-filtered position
  let currentDirs = { arrowup: false, arrowdown: false, arrowleft: false, arrowright: false };
  let lastDirChangeTime = 0;

  // Angle distance helper (handles wraparound)
  function angleDist(a, b) {
    let d = Math.abs(a - b) % 360;
    return d > 180 ? 360 - d : d;
  }

  function handleJoystickMove(touchX, touchY) {
    const rect = joystickBase.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    const maxR = rect.width / 2;

    let dx = touchX - cx;
    let dy = touchY - cy;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Clamp knob visual to base radius
    let knobDx = dx, knobDy = dy;
    if (dist > maxR) {
      knobDx = (dx / dist) * maxR;
      knobDy = (dy / dist) * maxR;
    }
    joystickKnob.classList.remove('idle');
    joystickKnob.style.transform = `translate(calc(-50% + ${knobDx}px), calc(-50% + ${knobDy}px))`;

    // Normalize to -1..1
    let nx = dx / maxR;
    let ny = dy / maxR;
    const mag = Math.sqrt(nx * nx + ny * ny);

    // Scaled radial dead zone: remap [DEAD_ZONE..1] → [0..1] smoothly
    if (mag < DEAD_ZONE) {
      smoothX *= 0.5;  // decay toward zero
      smoothY *= 0.5;
      applyDirections(0, 0, 0);
      return;
    }
    const scaledMag = Math.min(1, (mag - DEAD_ZONE) / (1 - DEAD_ZONE));
    nx = (nx / mag) * scaledMag;
    ny = (ny / mag) * scaledMag;

    // EMA smoothing
    smoothX = EMA_ALPHA * nx + (1 - EMA_ALPHA) * smoothX;
    smoothY = EMA_ALPHA * ny + (1 - EMA_ALPHA) * smoothY;

    const sMag = Math.sqrt(smoothX * smoothX + smoothY * smoothY);
    const angle = ((Math.atan2(smoothY, smoothX) * 180 / Math.PI) + 360) % 360;
    applyDirections(angle, sMag, Date.now());
  }

  function applyDirections(angle, magnitude, now) {
    if (magnitude < 0.05) {
      currentDirs.arrowup = false;
      currentDirs.arrowdown = false;
      currentDirs.arrowleft = false;
      currentDirs.arrowright = false;
    } else {
      // Cardinal centers: right=0, down=90, left=180, up=270
      const cardinals = [
        { key: 'arrowright', center: 0 },
        { key: 'arrowdown',  center: 90 },
        { key: 'arrowleft',  center: 180 },
        { key: 'arrowup',    center: 270 },
      ];

      // Threshold: 45° to enter a direction, 45+hysteresis to leave
      const enterThresh = 55;  // ~half of 110° zone
      const leaveThresh = enterThresh + HYSTERESIS_DEG;

      const cooldownOk = (now - lastDirChangeTime) >= DIR_COOLDOWN_MS;
      let changed = false;

      for (const c of cardinals) {
        const dist = angleDist(angle, c.center);
        if (currentDirs[c.key]) {
          // Currently active — only deactivate past leave threshold
          if (dist > leaveThresh && cooldownOk) {
            currentDirs[c.key] = false;
            changed = true;
          }
        } else {
          // Currently inactive — activate within enter threshold
          if (dist < enterThresh && cooldownOk) {
            currentDirs[c.key] = true;
            changed = true;
          }
        }
      }
      if (changed) lastDirChangeTime = now;
    }

    keys['arrowup']    = currentDirs.arrowup;
    keys['arrowdown']  = currentDirs.arrowdown;
    keys['arrowleft']  = currentDirs.arrowleft;
    keys['arrowright'] = currentDirs.arrowright;
  }

  function resetJoystick() {
    joystickTouchId = null;
    joystickKnob.classList.add('idle');
    joystickKnob.style.transform = 'translate(-50%, -50%)';
    smoothX = 0;
    smoothY = 0;
    currentDirs = { arrowup: false, arrowdown: false, arrowleft: false, arrowright: false };
    keys['arrowup'] = false;
    keys['arrowdown'] = false;
    keys['arrowleft'] = false;
    keys['arrowright'] = false;
  }

  joystickBase.addEventListener('touchstart', (e) => {
    e.preventDefault();
    emuFrame.focus();
    if (joystickTouchId === null) {
      const t = e.changedTouches[0];
      joystickTouchId = t.identifier;
      handleJoystickMove(t.clientX, t.clientY);
    }
  }, { passive: false });

  joystickBase.addEventListener('touchmove', (e) => {
    e.preventDefault();
    for (const t of e.changedTouches) {
      if (t.identifier === joystickTouchId) {
        handleJoystickMove(t.clientX, t.clientY);
        break;
      }
    }
  }, { passive: false });

  joystickBase.addEventListener('touchend', (e) => {
    for (const t of e.changedTouches) {
      if (t.identifier === joystickTouchId) {
        resetJoystick();
        break;
      }
    }
  });
  joystickBase.addEventListener('touchcancel', (e) => {
    for (const t of e.changedTouches) {
      if (t.identifier === joystickTouchId) {
        resetJoystick();
        break;
      }
    }
  });

  // Both buttons = Space (action_l) — matching hardware layout
  for (const btn of [btnL, btnR]) {
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      emuFrame.focus();
      keys[' '] = true;
      btn.classList.add('pressed');
    }, { passive: false });
    btn.addEventListener('touchend', (e) => {
      e.preventDefault();
      keys[' '] = false;
      btn.classList.remove('pressed');
    }, { passive: false });
    btn.addEventListener('touchcancel', () => {
      keys[' '] = false;
      btn.classList.remove('pressed');
    });
  }

  // Escape button
  btnEsc.addEventListener('touchstart', (e) => {
    e.preventDefault();
    emuFrame.focus();
    escapePressed = true;
  }, { passive: false });
  // Also handle click for non-touch pointer:coarse devices
  btnEsc.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    emuFrame.focus();
    escapePressed = true;
  });

  // Repeat guard for joystick-sourced pressed edges.
  // When the joystick is active, suppress rapid re-triggers of the same
  // direction that occur when the smoothed value briefly dips and recovers.
  const DIR_PRESS_COOLDOWN = 200;  // ms — min time between repeated "pressed" edges per direction
  const dirPressTime = { arrowup: 0, arrowdown: 0, arrowleft: 0, arrowright: 0 };

  function pushInputToPython() {
    const up = !!keys['arrowup'];
    const down = !!keys['arrowdown'];
    const left = !!keys['arrowleft'];
    const right = !!keys['arrowright'];
    const space = !!keys[' '];
    const z = !!keys['z'];

    const now = Date.now();
    const isTouch = joystickTouchId !== null;

    // Edge detection with touch repeat guard
    let up_p = up && !prevKeys['arrowup'];
    let down_p = down && !prevKeys['arrowdown'];
    let left_p = left && !prevKeys['arrowleft'];
    let right_p = right && !prevKeys['arrowright'];

    if (isTouch) {
      if (up_p    && now - dirPressTime.arrowup    < DIR_PRESS_COOLDOWN) up_p = false;
      if (down_p  && now - dirPressTime.arrowdown  < DIR_PRESS_COOLDOWN) down_p = false;
      if (left_p  && now - dirPressTime.arrowleft  < DIR_PRESS_COOLDOWN) left_p = false;
      if (right_p && now - dirPressTime.arrowright < DIR_PRESS_COOLDOWN) right_p = false;
    }
    if (up_p)    dirPressTime.arrowup    = now;
    if (down_p)  dirPressTime.arrowdown  = now;
    if (left_p)  dirPressTime.arrowleft  = now;
    if (right_p) dirPressTime.arrowright = now;

    const action_l = space && !prevKeys[' '];
    const action_r = z && !prevKeys['z'];
    lastActionPressed = action_l || action_r;
    prevKeys['arrowup'] = up;
    prevKeys['arrowdown'] = down;
    prevKeys['arrowleft'] = left;
    prevKeys['arrowright'] = right;
    prevKeys[' '] = space;
    prevKeys['z'] = z;
    const b = (v) => v ? 'True' : 'False';
    pyodide.runPython(
      `_input.up=${b(up)};_input.down=${b(down)};_input.left=${b(left)};_input.right=${b(right)}\n` +
      `_input.up_pressed=${b(up_p)};_input.down_pressed=${b(down_p)};_input.left_pressed=${b(left_p)};_input.right_pressed=${b(right_p)}\n` +
      `_input.action_l=${b(action_l)};_input.action_r=${b(action_r)};_input.action_l_held=${b(space)};_input.action_r_held=${b(z)}`
    );
  }

  function copyAndRender() {
    try {
      pyodide.runPython(`_frame = bytes(_display.buffer)`);
      const proxy = pyodide.globals.get('_frame');
      const arr = proxy.toJs();
      proxy.destroy();
      pyDisplay.buffer.set(arr);
      pyRenderer.render(pyDisplay);
    } catch (e) {
      console.error('Buffer copy error:', e);
    }
  }

  setStatus('loading Pyodide runtime...', 'loading');
  try {
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/pyodide/v0.27.4/full/pyodide.js';
    script.integrity = 'sha384-tSKqtqt5i9t+BKiXGOGifQBi2UQGv0DKKTl7grFv4cS4c8bc/Zc+PI+1O2Bj+xtC';
    script.crossOrigin = 'anonymous';
    document.head.appendChild(script);
    await new Promise((resolve, reject) => {
      script.onload = resolve;
      script.onerror = () => reject(new Error('Failed to load Pyodide CDN'));
    });
    setStatus('initializing Python...', 'loading');
    pyodide = await loadPyodide();
  } catch (e) {
    setStatus('failed to load: ' + e.message, 'error');
    return;
  }

  setStatus('loading catalog...', 'loading');
  try {
    const resp = await fetch(GITHUB_RAW + 'site/catalog.json');
    if (!resp.ok) throw new Error('HTTP ' + resp.status);
    catalog = await resp.json();
  } catch (e) {
    setStatus('catalog error: ' + e.message, 'error');
    return;
  }

  setStatus('setting up arcade environment...', 'loading');
  await pyodide.runPythonAsync(`
import sys, math, random, types
from collections import deque
from enum import Enum, auto

GRID_SIZE = 64

class Colors:
    BLACK = (0, 0, 0)
    WHITE = (255, 255, 255)
    RED = (255, 0, 0)
    GREEN = (0, 255, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)
    CYAN = (0, 255, 255)
    MAGENTA = (255, 0, 255)
    ORANGE = (255, 128, 0)
    PINK = (255, 128, 128)
    LIME = (128, 255, 0)
    PURPLE = (128, 0, 255)
    GRAY = (128, 128, 128)
    DARK_GRAY = (64, 64, 64)
    SNAKE = GREEN
    FOOD = RED
    WALL = GRAY
    PADDLE = WHITE
    BALL = WHITE
    BRICK = ORANGE
    PLAYER = CYAN
    ENEMY = RED
    BULLET = YELLOW

FONT_3X5 = {
    'A':['010','101','111','101','101'],'B':['110','101','110','101','110'],
    'C':['011','100','100','100','011'],'D':['110','101','101','101','110'],
    'E':['111','100','110','100','111'],'F':['111','100','110','100','100'],
    'G':['011','100','101','101','011'],'H':['101','101','111','101','101'],
    'I':['111','010','010','010','111'],'J':['001','001','001','101','010'],
    'K':['101','110','100','110','101'],'L':['100','100','100','100','111'],
    'M':['101','111','111','101','101'],'N':['101','111','111','111','101'],
    'O':['010','101','101','101','010'],'P':['110','101','110','100','100'],
    'Q':['010','101','101','110','011'],'R':['110','101','110','101','101'],
    'S':['011','100','010','001','110'],'T':['111','010','010','010','010'],
    'U':['101','101','101','101','011'],'V':['101','101','101','010','010'],
    'W':['101','101','111','111','101'],'X':['101','101','010','101','101'],
    'Y':['101','101','010','010','010'],'Z':['111','001','010','100','111'],
    '0':['111','101','101','101','111'],'1':['010','110','010','010','111'],
    '2':['110','001','010','100','111'],'3':['110','001','010','001','110'],
    '4':['101','101','111','001','001'],'5':['111','100','110','001','110'],
    '6':['011','100','110','101','010'],'7':['111','001','010','010','010'],
    '8':['010','101','010','101','010'],'9':['010','101','011','001','110'],
    ' ':['000','000','000','000','000'],':':['000','010','000','010','000'],
    '-':['000','000','111','000','000'],'.':['000','000','000','000','010'],
    '!':['010','010','010','000','010'],'?':['110','001','010','000','010'],
    '/':['001','001','010','100','100'],
    "'":['010','010','000','000','000'],
    '+':['000','010','111','010','000'],
    '*':['101','010','111','010','101'],
    '(':['010','100','100','100','010'],
    ')':['010','001','001','001','010'],
}

class Display:
    def __init__(self):
        self.buffer = bytearray(GRID_SIZE * GRID_SIZE * 3)

    def clear(self, color=None):
        if color is None: color = (0, 0, 0)
        r, g, b = int(color[0]), int(color[1]), int(color[2])
        buf = self.buffer
        for i in range(0, len(buf), 3):
            buf[i] = r; buf[i+1] = g; buf[i+2] = b

    def set_pixel(self, x, y, color):
        x, y = int(x), int(y)
        if 0 <= x < GRID_SIZE and 0 <= y < GRID_SIZE:
            i = (y * GRID_SIZE + x) * 3
            buf = self.buffer
            buf[i] = max(0, min(255, int(color[0])))
            buf[i+1] = max(0, min(255, int(color[1])))
            buf[i+2] = max(0, min(255, int(color[2])))

    def get_pixel(self, x, y):
        x, y = int(x), int(y)
        if 0 <= x < GRID_SIZE and 0 <= y < GRID_SIZE:
            i = (y * GRID_SIZE + x) * 3
            return (self.buffer[i], self.buffer[i+1], self.buffer[i+2])
        return (0, 0, 0)

    def draw_rect(self, x, y, w, h, color, filled=True):
        x, y, w, h = int(x), int(y), int(w), int(h)
        if filled:
            for py in range(max(0, y), min(GRID_SIZE, y + h)):
                for px in range(max(0, x), min(GRID_SIZE, x + w)):
                    self.set_pixel(px, py, color)
        else:
            for px in range(x, x + w):
                self.set_pixel(px, y, color); self.set_pixel(px, y + h - 1, color)
            for py in range(y, y + h):
                self.set_pixel(x, py, color); self.set_pixel(x + w - 1, py, color)

    def draw_line(self, x0, y0, x1, y1, color):
        x0, y0, x1, y1 = int(x0), int(y0), int(x1), int(y1)
        dx = abs(x1 - x0); dy = -abs(y1 - y0)
        sx = 1 if x0 < x1 else -1; sy = 1 if y0 < y1 else -1
        err = dx + dy
        while True:
            self.set_pixel(x0, y0, color)
            if x0 == x1 and y0 == y1: break
            e2 = 2 * err
            if e2 >= dy: err += dy; x0 += sx
            if e2 <= dx: err += dx; y0 += sy

    def draw_circle(self, cx, cy, r, color, filled=False):
        for dy in range(-r, r + 1):
            for dx in range(-r, r + 1):
                d2 = dx * dx + dy * dy
                if filled:
                    if d2 <= r * r: self.set_pixel(cx + dx, cy + dy, color)
                else:
                    if abs(d2 - r * r) < r * 2: self.set_pixel(cx + dx, cy + dy, color)

    def draw_text_small(self, x, y, text, color):
        cursor = int(x)
        for char in text.upper():
            glyph = FONT_3X5.get(char)
            if glyph:
                for r in range(5):
                    for c in range(3):
                        if glyph[r][c] == '1':
                            self.set_pixel(cursor + c, int(y) + r, color)
            cursor += 4

    def set_gamma(self, gamma, toe): pass
    def render(self): pass

class GameState(Enum):
    PLAYING = auto()
    PAUSED = auto()
    GAME_OVER = auto()
    WIN = auto()

class InputState:
    def __init__(self):
        self.reset()
    def reset(self):
        self.up = False
        self.down = False
        self.left = False
        self.right = False
        self.up_pressed = False
        self.down_pressed = False
        self.left_pressed = False
        self.right_pressed = False
        self.action_l = False
        self.action_r = False
        self.action_l_held = False
        self.action_r_held = False
    @property
    def dx(self):
        return (1 if self.right else 0) - (1 if self.left else 0)
    @property
    def dy(self):
        return (1 if self.down else 0) - (1 if self.up else 0)
    @property
    def any_direction(self):
        return self.up or self.down or self.left or self.right

class Game:
    name = "Unnamed Game"
    description = ""
    category = ""
    def __init__(self, display):
        self.display = display
        self.state = GameState.PLAYING
        self.score = 0
        self.high_score = 0
    def reset(self): pass
    def update(self, input_state, dt): pass
    def draw(self): pass
    def draw_score(self, y=1):
        self.display.draw_text_small(1, y, str(self.score), Colors.WHITE)
    def draw_game_over(self, selection=0):
        self.display.clear(Colors.BLACK)
        if hasattr(self, 'state') and self.state == GameState.WIN:
            self.display.draw_text_small(8, 20, "YOU WIN!", Colors.YELLOW)
        else:
            self.display.draw_text_small(8, 20, "GAME OVER", Colors.RED)
        self.display.draw_text_small(12, 30, "SCORE:" + str(self.score), Colors.WHITE)
        if selection == 0:
            self.display.draw_text_small(4, 44, ">PLAY AGAIN", Colors.YELLOW)
            self.display.draw_text_small(4, 54, " MENU", Colors.GRAY)
        else:
            self.display.draw_text_small(4, 44, " PLAY AGAIN", Colors.GRAY)
            self.display.draw_text_small(4, 54, ">MENU", Colors.YELLOW)

class Visual:
    name = "Unnamed"
    description = ""
    category = ""
    def __init__(self, display):
        self.display = display
        self.time = 0.0
        self.wants_exit = False
        self.reset()
    def reset(self): pass
    def update(self, dt): self.time += dt
    def draw(self): pass
    def handle_input(self, input_state): return False

# --- sys.modules shimming ---
_arcade_mod = types.ModuleType('arcade')
for _n in ['Display', 'Colors', 'GRID_SIZE', 'Game', 'GameState', 'InputState',
           'Visual', 'FONT_3X5']:
    setattr(_arcade_mod, _n, eval(_n))
sys.modules['arcade'] = _arcade_mod

_visuals_mod = types.ModuleType('visuals')
for _n in ['Visual', 'Display', 'Colors', 'GRID_SIZE']:
    setattr(_visuals_mod, _n, eval(_n))
sys.modules['visuals'] = _visuals_mod

_games_mod = types.ModuleType('games')
sys.modules['games'] = _games_mod

for _stub_name in ['highscores', 'settings', 'transitions', 'catalog']:
    _stub = types.ModuleType(_stub_name)
    sys.modules[_stub_name] = _stub

class _HighScoreManager:
    def get_top_scores(self, *a, **kw): return []
    def is_high_score(self, *a, **kw): return False
    def add_score(self, *a, **kw): return -1
    def log_play(self, *a, **kw): pass
sys.modules['highscores'].HighScoreManager = _HighScoreManager
sys.modules['highscores'].get_high_score_manager = lambda: _HighScoreManager()

_display = Display()
_input = InputState()
_item = None
_is_game = False
_game_over_sel = 0
_exit_hold = 0.0
  `);

  const catJson = JSON.stringify(catalog);
  await pyodide.runPythonAsync(`
import json as _json

_catalog = _json.loads('''${catJson.replace(/\\/g, '\\\\').replace(/'/g, "\\'")}''')

class EmulatorMenu:
    def __init__(self, catalog):
        self.categories = catalog['categories']
        self.cat_index = 0
        self.item_index = 0
        # Auto-scroll state (vertical)
        self.scroll_dir = 0
        self.scroll_held = 0.0
        self.scroll_accum = 0.0
        # Auto-scroll state (horizontal)
        self.cat_scroll_dir = 0
        self.cat_scroll_held = 0.0
        self.cat_scroll_accum = 0.0

    def handle_input(self, inp, dt):
        cats = self.categories
        if not cats:
            return None
        cat = cats[self.cat_index]
        items = cat.get('items', [])

        # Category navigation (left/right) with scroll acceleration
        if len(cats) > 1:
            if inp.left_pressed:
                self.cat_index = (self.cat_index - 1) % len(cats)
                self.item_index = 0
                self.cat_scroll_dir = -1
                self.cat_scroll_held = 0.0
                self.cat_scroll_accum = 0.0
                self.scroll_dir = 0
                self.scroll_held = 0.0
                self.scroll_accum = 0.0
            elif inp.right_pressed:
                self.cat_index = (self.cat_index + 1) % len(cats)
                self.item_index = 0
                self.cat_scroll_dir = 1
                self.cat_scroll_held = 0.0
                self.cat_scroll_accum = 0.0
                self.scroll_dir = 0
                self.scroll_held = 0.0
                self.scroll_accum = 0.0
            elif self.cat_scroll_dir != 0 and ((self.cat_scroll_dir == -1 and inp.left) or (self.cat_scroll_dir == 1 and inp.right)):
                self.cat_scroll_held += dt
                if self.cat_scroll_held >= 0.4:
                    t_accel = min(self.cat_scroll_held - 0.4, 1.5)
                    interval = 0.18 - (0.12 * t_accel / 1.5)
                    self.cat_scroll_accum += dt
                    while self.cat_scroll_accum >= interval:
                        self.cat_scroll_accum -= interval
                        self.cat_index = (self.cat_index + self.cat_scroll_dir) % len(cats)
                        self.item_index = 0
            else:
                self.cat_scroll_dir = 0
                self.cat_scroll_held = 0.0
                self.cat_scroll_accum = 0.0

        # Item navigation (up/down) with scroll acceleration
        if items:
            n_items = len(items)
            if inp.up_pressed:
                self.item_index = (self.item_index - 1) % n_items
                self.scroll_dir = -1
                self.scroll_held = 0.0
                self.scroll_accum = 0.0
            elif inp.down_pressed:
                self.item_index = (self.item_index + 1) % n_items
                self.scroll_dir = 1
                self.scroll_held = 0.0
                self.scroll_accum = 0.0
            elif self.scroll_dir != 0 and ((self.scroll_dir == -1 and inp.up) or (self.scroll_dir == 1 and inp.down)):
                self.scroll_held += dt
                if self.scroll_held >= 0.4:
                    t_accel = min(self.scroll_held - 0.4, 1.5)
                    interval = 0.18 - (0.12 * t_accel / 1.5)
                    self.scroll_accum += dt
                    while self.scroll_accum >= interval:
                        self.scroll_accum -= interval
                        self.item_index = (self.item_index + self.scroll_dir) % n_items
            else:
                self.scroll_dir = 0
                self.scroll_held = 0.0
                self.scroll_accum = 0.0

            if inp.action_l or inp.action_r:
                return items[self.item_index]
        return None

    def draw(self, display):
        display.clear(Colors.BLACK)
        cats = self.categories
        if not cats:
            display.draw_text_small(2, 30, "NO ITEMS", Colors.RED)
            return
        cat = cats[self.cat_index]
        cat_color = tuple(cat['color'])
        items = cat.get('items', [])

        display.draw_text_small(4, 2, cat['name'], cat_color)

        if len(cats) > 1:
            display.set_pixel(1, 4, Colors.GRAY)
            display.set_pixel(0, 5, Colors.GRAY)
            display.set_pixel(1, 6, Colors.GRAY)
            display.set_pixel(62, 4, Colors.GRAY)
            display.set_pixel(63, 5, Colors.GRAY)
            display.set_pixel(62, 6, Colors.GRAY)

        n = len(cats)
        vis_dots = min(n, 12)
        spacing = 4
        ws = max(0, min(self.cat_index - vis_dots // 2, n - vis_dots))
        we = min(ws + vis_dots, n)
        tw = (we - ws) * spacing
        dx = 32 - tw // 2
        if ws > 0:
            display.set_pixel(2, 9, Colors.GRAY)
            display.set_pixel(3, 8, Colors.GRAY)
            display.set_pixel(3, 10, Colors.GRAY)
        if we < n:
            display.set_pixel(61, 9, Colors.GRAY)
            display.set_pixel(60, 8, Colors.GRAY)
            display.set_pixel(60, 10, Colors.GRAY)
        for i in range(ws, we):
            px = dx + (i - ws) * spacing
            c = Colors.WHITE if i == self.cat_index else Colors.DARK_GRAY
            display.set_pixel(px, 9, c)

        display.draw_line(0, 11, 63, 11, Colors.DARK_GRAY)

        if not items:
            display.draw_text_small(8, 30, "EMPTY", Colors.GRAY)
            return
        visible = 5
        si = max(0, self.item_index - visible // 2)
        if si + visible > len(items):
            si = max(0, len(items) - visible)
        for i, item in enumerate(items[si:si + visible]):
            ai = si + i
            y = 14 + i * 8
            if ai == self.item_index:
                display.draw_rect(0, y - 1, 64, 7, Colors.DARK_GRAY)
                display.draw_text_small(2, y, ">" + item['name'], cat_color)
            else:
                display.draw_text_small(2, y, " " + item['name'], Colors.WHITE)
        if si > 0:
            display.draw_text_small(58, 14, "^", Colors.GRAY)
        if si + visible < len(items):
            display.draw_text_small(58, 14 + (visible - 1) * 8, "v", Colors.GRAY)

        display.draw_line(0, 56, 63, 56, Colors.DARK_GRAY)
        display.draw_text_small(8, 58, "PRESS TO PLAY", Colors.GRAY)

_menu = EmulatorMenu(_catalog)
  `);

  async function loadPaintingAtlas() {
    if (paintingAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/paintings_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_PAINTING_PIXELS', pyDict);
      pyDict.destroy();
      paintingAtlasLoaded = true;
    } catch(e) {
      console.error('Painting atlas error:', e);
    }
  }

  async function loadFlagsAtlas() {
    if (flagsAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/flags_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_FLAGS_PIXELS', pyDict);
      pyDict.destroy();
      flagsAtlasLoaded = true;
    } catch(e) {
      console.error('Flags atlas error:', e);
    }
  }

  async function loadSignsAtlas() {
    if (signsAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/signs_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_SIGNS_PIXELS', pyDict);
      pyDict.destroy();
      signsAtlasLoaded = true;
    } catch(e) {
      console.error('Signs atlas error:', e);
    }
  }

  async function loadGalleryAtlas() {
    if (galleryAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/gallery_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_GALLERY_PIXELS', pyDict);
      pyDict.destroy();
      galleryAtlasLoaded = true;
    } catch(e) {
      console.error('Gallery atlas error:', e);
    }
  }

  async function loadHaeckelAtlas() {
    if (haeckelAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/haeckel_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_HAECKEL_PIXELS', pyDict);
      pyDict.destroy();
      haeckelAtlasLoaded = true;
    } catch(e) {
      console.error('Haeckel atlas error:', e);
    }
  }

  async function loadAudubonAtlas() {
    if (audubonAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/audubon_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_AUDUBON_PIXELS', pyDict);
      pyDict.destroy();
      audubonAtlasLoaded = true;
    } catch(e) {
      console.error('Audubon atlas error:', e);
    }
  }

  async function loadMerianAtlas() {
    if (merianAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/merian_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_MERIAN_PIXELS', pyDict);
      pyDict.destroy();
      merianAtlasLoaded = true;
    } catch(e) {
      console.error('Merian atlas error:', e);
    }
  }

  async function loadRedouteAtlas() {
    if (redouteAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/redoute_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_REDOUTE_PIXELS', pyDict);
      pyDict.destroy();
      redouteAtlasLoaded = true;
    } catch(e) {
      console.error('Redoute atlas error:', e);
    }
  }

  async function loadSebaAtlas() {
    if (sebaAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/seba_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_SEBA_PIXELS', pyDict);
      pyDict.destroy();
      sebaAtlasLoaded = true;
    } catch(e) {
      console.error('Seba atlas error:', e);
    }
  }

  async function loadGouldAtlas() {
    if (gouldAtlasLoaded) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/gould_atlas.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      const pyDict = pyodide.toPy(atlas);
      pyodide.globals.set('_GOULD_PIXELS', pyDict);
      pyDict.destroy();
      gouldAtlasLoaded = true;
    } catch(e) {
      console.error('Gould atlas error:', e);
    }
  }

  const museumAtlasLoaded = {};
  async function loadMuseumAtlas(clsName) {
    if (museumAtlasLoaded[clsName]) return;
    try {
      const resp = await fetch(GITHUB_RAW + 'site/gallery_' + clsName + '.json');
      if (!resp.ok) return;
      const atlas = await resp.json();
      // Merge museum data into the _GALLERY_PIXELS global dict via Python
      const pyAtlas = pyodide.toPy(atlas);
      pyodide.globals.set('_tmp_museum', pyAtlas);
      pyodide.runPython(`
_gp = globals().get('_GALLERY_PIXELS', {})
_gp.update(_tmp_museum)
globals()['_GALLERY_PIXELS'] = _gp
del _tmp_museum
      `);
      pyAtlas.destroy();
      museumAtlasLoaded[clsName] = true;
    } catch(e) {
      console.error('Museum atlas error for ' + clsName + ':', e);
    }
  }

  async function loadPythonModule(modulePath) {
    if (loadedModules.has(modulePath)) return true;
    try {
      const resp = await fetch(GITHUB_RAW + modulePath);
      if (!resp.ok) throw new Error('HTTP ' + resp.status + ' for ' + modulePath);
      let source = await resp.text();

      let pkgName, modName;
      if (modulePath.startsWith('games/')) {
        pkgName = 'games';
        modName = modulePath.replace('games/', '').replace('.py', '');
      } else if (modulePath.startsWith('visuals/')) {
        pkgName = 'visuals';
        modName = modulePath.replace('visuals/', '').replace('.py', '');
      } else {
        pkgName = '';
        modName = modulePath.replace('.py', '');
      }

      source = source.replace(/^from \. import /gm, 'from ' + pkgName + ' import ');
      source = source.replace(/^from \.(\w+) import /gm, 'from ' + pkgName + '.$1 import ');
      source = source.replace(/^sys\.path\..*/gm, '');

      // Load numpy on demand if the source imports it
      if (/^import numpy|^from numpy /m.test(source)) {
        await pyodide.loadPackage('numpy');
      }

      // Load atlases before their respective modules
      if (modulePath === 'visuals/painting.py') {
        await loadPaintingAtlas();
      }
      if (modulePath === 'visuals/flags.py') {
        await loadFlagsAtlas();
      }
      if (modulePath === 'visuals/signs.py') {
        await loadSignsAtlas();
      }
      if (modulePath === 'visuals/plates.py') {
        await loadHaeckelAtlas();
        await loadAudubonAtlas();
        await loadMerianAtlas();
        await loadRedouteAtlas();
        await loadSebaAtlas();
        await loadGouldAtlas();
      }
      if (modulePath === 'visuals/gallery3d.py') {
        await loadPaintingAtlas();
        await loadGalleryAtlas();
      }

      pyodide.runPython(source);

      if (pkgName && modName) {
        const fullName = pkgName + '.' + modName;
        pyodide.runPython(`
import types as _t
if '${fullName}' not in sys.modules:
    _m = _t.ModuleType('${fullName}')
    sys.modules['${fullName}'] = _m
else:
    _m = sys.modules['${fullName}']
for _k, _v in dict(globals()).items():
    if not _k.startswith('_'):
        setattr(_m, _k, _v)
        if hasattr(_v, '__class__') and isinstance(_v, type):
            setattr(sys.modules['${pkgName}'], _k, _v)
        `);
      }

      loadedModules.add(modulePath);
      return true;
    } catch (e) {
      console.error('Module load error for ' + modulePath + ':', e);
      return false;
    }
  }

  async function launchItem(itemData) {
    emuState = 'loading';
    setStatus('loading ' + itemData.name + '...', 'loading');

    pyodide.runPython(`
_display.clear(Colors.BLACK)
_display.draw_text_small(6, 28, "LOADING...", Colors.CYAN)
    `);
    copyAndRender();

    // Handle playlists: redirect to a random member
    if (itemData.playlist) {
      playlistItems = itemData.playlist;
      playlistIsGame = !!itemData.is_game;
      playlistCycleTimer = 0;
      itemData = playlistItems[Math.floor(Math.random() * playlistItems.length)];
    }

    const deps = itemData.deps || [];
    for (const dep of deps) {
      const ok = await loadPythonModule(dep);
      if (!ok) {
        showError('DEP FAIL: ' + dep);
        return;
      }
    }

    const ok = await loadPythonModule(itemData.module);
    if (!ok) {
      showError('LOAD FAIL');
      return;
    }

    // Load sprite museum atlas on demand before instantiation (local-only galleries)
    if (itemData.cls && itemData.cls.startsWith('Gallery') && itemData.cls !== 'Gallery3D') {
      await loadMuseumAtlas(itemData.cls);
    }

    try {
      const isGame = playlistItems ? playlistIsGame : !!itemData.is_game;
      pyodide.runPython(`
_item = ${itemData.cls}(_display)
_is_game = ${isGame ? 'True' : 'False'}
_game_over_sel = 0
_exit_hold = 0.0
      `);
      emuState = 'running';
      setStatus('running: ' + itemData.name, 'ready');
    } catch (e) {
      console.error('Instantiate error:', e);
      showError(e.message.split('\\n')[0].substring(0, 30));
    }
  }

  function showError(msg) {
    emuState = 'error';
    const safeMsg = String(msg).replace(/[^A-Za-z0-9 .:_-]/g, '').substring(0, 15);
    try {
      pyodide.runPython(`
_display.clear(Colors.BLACK)
_display.draw_text_small(2, 24, "ERROR", Colors.RED)
_display.draw_text_small(2, 36, "${safeMsg}", Colors.GRAY)
      `);
      copyAndRender();
    } catch (e2) { /* ignore render errors during error display */ }
    setStatus('error: ' + msg, 'error');
    setTimeout(() => { returnToMenu(); }, 2000);
  }

  function returnToMenu() {
    pyodide.runPython(`
_item = None
_exit_hold = 0.0
_game_over_sel = 0
    `);
    playlistItems = null;
    playlistIsGame = false;
    playlistCycleTimer = 0;
    isIdle = false;
    idleTimer = 0;
    idleCycleTimer = 0;
    emuState = 'menu';
    setStatus('menu', 'ready');
  }

  async function swapPlaylistVisual() {
    if (!playlistItems || playlistIsGame) return;
    const item = playlistItems[Math.floor(Math.random() * playlistItems.length)];
    for (const dep of (item.deps || [])) {
      await loadPythonModule(dep);
    }
    await loadPythonModule(item.module);
    if (emuState !== 'running' || !playlistItems) return;
    try {
      pyodide.runPython(`_item = ${item.cls}(_display)\n_exit_hold = 0.0`);
      playlistCycleTimer = 0;
      setStatus('running: ' + item.name, 'ready');
    } catch(e) { console.error('Visual swap error:', e); }
  }

  async function loadNextPlaylistGame() {
    if (!playlistItems || !playlistIsGame) return;
    const item = playlistItems[Math.floor(Math.random() * playlistItems.length)];
    emuState = 'loading';
    setStatus('loading ' + item.name + '...', 'loading');
    pyodide.runPython(`
_display.clear(Colors.BLACK)
_display.draw_text_small(6, 28, "LOADING...", Colors.CYAN)
    `);
    copyAndRender();
    for (const dep of (item.deps || [])) {
      if (!await loadPythonModule(dep)) { showError('DEP FAIL'); return; }
    }
    if (!await loadPythonModule(item.module)) { showError('LOAD FAIL'); return; }
    try {
      pyodide.runPython(`
_item = ${item.cls}(_display)
_is_game = True
_game_over_sel = 0
_exit_hold = 0.0
      `);
      emuState = 'running';
      setStatus('running: ' + item.name, 'ready');
    } catch(e) {
      showError(e.message.split('\\n')[0].substring(0, 30));
    }
  }

  async function launchIdleVisual() {
    if (!isIdle || idlePool.length === 0) return;
    const item = idlePool[Math.floor(Math.random() * idlePool.length)];
    const ok = await loadPythonModule(item.module);
    if (!ok || !isIdle) return;
    try {
      pyodide.runPython(`_item = ${item.cls}(_display)`);
      idleCycleTimer = 0;
    } catch(e) { console.error('Idle visual error:', e); }
  }

  setStatus('ready', 'ready');
  emuState = 'menu';

  let pyLastTime = performance.now();
  let pyFrameCount = 0;
  let pyFpsTimer = 0;
  let pendingLaunch = null;
  let playlistItems = null;
  let playlistIsGame = false;
  let playlistCycleTimer = 0;
  let idleTimer = 0;
  let isIdle = false;
  let idleCycleTimer = 0;
  let idlePool = [];
  let lastActionPressed = false;

  // Build idle pool: no-dep, non-game, non-utility visuals for screensaver
  for (const cat of catalog.categories) {
    if (cat.key === 'utility' || cat.key === 'visual_mix' || cat.key === 'game_mix') continue;
    for (const item of cat.items) {
      if (!item.is_game && !item.deps && !item.needs_numpy && !item.playlist) {
        idlePool.push(item);
      }
    }
  }

  function pyLoop(timestamp) {
    const dt = Math.min((timestamp - pyLastTime) / 1000, 0.05);
    pyLastTime = timestamp;

    if (hasFocus) {
      pushInputToPython();
    } else {
      pyodide.runPython('_input.reset()');
    }

    try {
      if (emuState === 'menu') {
        escapePressed = false;

        if (isIdle) {
          // Idle screensaver mode
          const hasInput = keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright'] || keys[' '] || keys['z'];
          if (hasInput) {
            isIdle = false;
            idleTimer = 0;
            idleCycleTimer = 0;
            pyodide.runPython('_item = None');
          } else {
            idleCycleTimer += dt;
            if (idleCycleTimer >= 30) {
              launchIdleVisual();
            }
            pyodide.runPython(`
if _item:
    _item.update(${dt})
    _item.draw()
else:
    _display.clear()
            `);
          }
          copyAndRender();
        } else {
          const result = pyodide.runPython(`
_sel = _menu.handle_input(_input, ${dt})
_menu.draw(_display)
_sel
          `);
          if (result && result.toJs) {
            const item = Object.fromEntries(result.toJs());
            result.destroy();
            pendingLaunch = item;
          } else if (result !== null && result !== undefined && typeof result !== 'boolean') {
            try { result.destroy && result.destroy(); } catch(e) {}
          }
          copyAndRender();

          // Idle timer
          const hasInput = keys['arrowup'] || keys['arrowdown'] || keys['arrowleft'] || keys['arrowright'] || keys[' '] || keys['z'];
          if (hasInput) {
            idleTimer = 0;
          } else {
            idleTimer += dt;
            if (idleTimer >= 60 && idlePool.length > 0) {
              isIdle = true;
              idleCycleTimer = 0;
              launchIdleVisual();
            }
          }

          if (pendingLaunch) {
            const item = pendingLaunch;
            pendingLaunch = null;
            idleTimer = 0;
            launchItem(item);
          }
        }

      } else if (emuState === 'running') {
        if (escapePressed) {
          escapePressed = false;
          returnToMenu();
        } else {
          const stateStr = pyodide.runPython(`
if _item:
    if _is_game:
        try:
            _item.update(_input, ${dt})
            _item.draw()
        except Exception as _e:
            _item.state = GameState.GAME_OVER
        if _input.action_l_held and _input.action_r_held:
            _exit_hold += ${dt}
        else:
            _exit_hold = 0.0
        if _exit_hold >= 2.0:
            'exit'
        elif hasattr(_item, 'state') and _item.state in (GameState.GAME_OVER, GameState.WIN):
            'gameover'
        else:
            'ok'
    else:
        _item.handle_input(_input)
        _item.update(${dt})
        _item.draw()
        both = _input.action_l_held and _input.action_r_held
        either = _input.action_l_held or _input.action_r_held
        if both:
            _exit_hold += ${dt} * 2.0
        elif either:
            _exit_hold += ${dt}
        else:
            _exit_hold = 0.0
        if _exit_hold >= 1.0 or getattr(_item, 'wants_exit', False):
            'exit'
        else:
            'ok'
else:
    'exit'
          `);
          copyAndRender();

          if (stateStr === 'exit') {
            returnToMenu();
          } else if (stateStr === 'gameover') {
            emuState = 'gameover';
            pyodide.runPython(`_game_over_sel = 0`);
          }

          // Visual playlist: auto-cycle and button skip
          if (emuState === 'running' && playlistItems && !playlistIsGame) {
            playlistCycleTimer += dt;
            if (playlistCycleTimer >= 30 || lastActionPressed) {
              swapPlaylistVisual();
            }
          }
        }

      } else if (emuState === 'gameover') {
        if (escapePressed) {
          escapePressed = false;
          returnToMenu();
        } else {
          const goResult = pyodide.runPython(`
_r = 'show'
if _input.up_pressed or _input.down_pressed:
    _game_over_sel = 1 - _game_over_sel
elif _input.action_l or _input.action_r:
    if _game_over_sel == 0:
        _r = 'again'
    else:
        _r = 'menu'
if _input.action_l_held and _input.action_r_held:
    _exit_hold += ${dt}
else:
    _exit_hold = 0.0
if _exit_hold >= 2.0:
    _r = 'menu'
if _item:
    _item.draw_game_over(_game_over_sel)
_r
          `);

          // Overdraw "PLAY AGAIN" with "NEXT GAME" for game playlists
          if (playlistItems && playlistIsGame) {
            pyodide.runPython(`
_display.draw_rect(4, 43, 56, 7, Colors.BLACK)
if _game_over_sel == 0:
    _display.draw_text_small(4, 44, ">NEXT GAME", Colors.YELLOW)
else:
    _display.draw_text_small(4, 44, " NEXT GAME", Colors.GRAY)
            `);
          }

          copyAndRender();

          if (goResult === 'again') {
            if (playlistItems && playlistIsGame) {
              loadNextPlaylistGame();
            } else {
              pyodide.runPython(`
_item.score = 0
_item.state = GameState.PLAYING
_item.reset()
_exit_hold = 0.0
              `);
              emuState = 'running';
              setStatus('running', 'ready');
            }
          } else if (goResult === 'menu') {
            returnToMenu();
          }
        }
      }
      if (escapePressed && (emuState === 'loading' || emuState === 'error')) {
        escapePressed = false;
        returnToMenu();
      }
    } catch (e) {
      console.error('Emulator frame error:', e);
      showError(e.message ? e.message.split('\\n')[0].substring(0, 30) : 'runtime error');
    }

    pyFrameCount++;
    pyFpsTimer += dt;
    if (pyFpsTimer >= 1.0) {
      pyFpsEl.textContent = pyFrameCount + ' fps \u00b7 Python via Pyodide';
      pyFrameCount = 0;
      pyFpsTimer = 0;
    }

    requestAnimationFrame(pyLoop);
  }

  requestAnimationFrame(pyLoop);
})();
</script>
</body>
</html>
