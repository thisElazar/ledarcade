<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wonder Cabinet</title>
<link rel="stylesheet" href="shared.css">
<style>
/* --- Showcase --- */
.showcase {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 20px 0;
}
.display-frame {
  background: linear-gradient(145deg, #151517, #101012);
  border-radius: 16px;
  padding: 18px;
  box-shadow:
    0 8px 40px rgba(0,0,0,0.7),
    inset 0 1px 0 rgba(255,255,255,0.04);
  transition: box-shadow 0.8s ease;
  position: relative;
}
.canvas-wrap {
  position: relative;
  width: min(640px, 84vw);
  aspect-ratio: 1;
  background: #000;
  border-radius: 4px;
  overflow: hidden;
  box-shadow: inset 0 2px 10px rgba(0,0,0,0.9);
}
canvas.led {
  display: block;
  width: 100%;
  height: 100%;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  position: relative;
  z-index: 2;
}
canvas.glow {
  position: absolute;
  top: -2%; left: -2%;
  width: 104%; height: 104%;
  filter: blur(5px) brightness(1.6);
  opacity: 0.35;
  pointer-events: none;
  z-index: 1;
  image-rendering: auto;
}

/* --- Visual Info --- */
.visual-info {
  text-align: center;
  margin-top: 20px;
  min-height: 50px;
  transition: opacity 0.15s ease;
}
.visual-info .name {
  display: block;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 0.1em;
  color: #e8e0d4;
}
.visual-info .desc {
  display: block;
  font-size: 12px;
  color: #7a7264;
  letter-spacing: 0.08em;
  margin-top: 2px;
}
.visual-info .category {
  display: inline-block;
  font-size: 10px;
  letter-spacing: 0.15em;
  padding: 2px 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.1);
  color: #9a9284;
  margin-top: 6px;
}

/* --- Navigation --- */
.visual-nav {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-top: 20px;
}
.nav-btn {
  background: none;
  border: 1px solid rgba(255,255,255,0.12);
  color: #8a8274;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}
.nav-btn:hover {
  border-color: rgba(200, 168, 110, 0.4);
  color: #c8a86e;
  background: rgba(200, 168, 110, 0.05);
}
.nav-dots {
  display: flex;
  gap: 8px;
}
.nav-dots .dot {
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: rgba(255,255,255,0.15);
  transition: all 0.3s;
  cursor: pointer;
}
.nav-dots .dot.active {
  background: #c8a86e;
  box-shadow: 0 0 6px rgba(200, 168, 110, 0.5);
}
.hint {
  font-size: 11px;
  color: #4a4438;
  letter-spacing: 0.05em;
  margin-top: 16px;
  text-align: center;
}

/* --- About --- */
.about {
  max-width: 620px;
  margin: 0 auto;
  padding: 0 24px 30px;
  text-align: center;
}
.about h2 {
  font-size: 13px;
  font-weight: 400;
  letter-spacing: 0.3em;
  color: #c8a86e;
  margin-bottom: 24px;
}
.stats {
  display: flex;
  justify-content: center;
  gap: clamp(24px, 6vw, 60px);
  margin-bottom: 30px;
}
.stat .number {
  display: block;
  font-size: clamp(32px, 6vw, 48px);
  font-weight: 200;
  color: #e8e0d4;
  line-height: 1;
}
.stat .label {
  display: block;
  font-size: 10px;
  letter-spacing: 0.2em;
  color: #6a6254;
  margin-top: 6px;
}
.about p {
  font-size: 14px;
  color: #8a8274;
  line-height: 1.8;
  max-width: 500px;
  margin: 0 auto;
}

/* --- Collection --- */
.collection {
  max-width: 700px;
  margin: 0 auto;
  padding: 0 24px 80px;
  text-align: center;
}
.collection h2 {
  font-size: 13px;
  font-weight: 400;
  letter-spacing: 0.3em;
  color: #c8a86e;
  margin-bottom: 24px;
}
.cat-grid {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 6px 12px;
  max-width: 560px;
  margin: 0 auto;
}
.cat-tag {
  font-size: 11px;
  font-family: 'SF Mono', 'Menlo', 'Consolas', monospace;
  letter-spacing: 0.06em;
  padding: 4px 10px;
  border-radius: 4px;
  background: rgba(255,255,255,0.03);
  border: 1px solid rgba(255,255,255,0.06);
  white-space: nowrap;
}

@media (max-width: 500px) {
  .display-frame { padding: 10px; border-radius: 10px; }
}
</style>
</head>

<body>

<nav class="site-nav">
  <a class="nav-brand" href="index.html">WONDER CABINET</a>
  <a href="index.html" class="active">HOME</a>
  <a href="emulator.html">EMULATOR</a>
  <a href="timeline.html">TIMELINE</a>
  <a href="guide.html">FIELD GUIDE</a>
</nav>

<header>
  <h1>WONDER CABINET</h1>
  <p class="tagline">A cabinet of electronic curiosities</p>
</header>

<section class="showcase">
  <div class="display-frame" id="frame">
    <div class="canvas-wrap" id="canvasWrap">
      <canvas class="glow" id="glowCanvas" width="64" height="64"></canvas>
      <canvas class="led" id="ledCanvas" width="640" height="640"></canvas>
    </div>
  </div>

  <div class="visual-info" id="info">
    <span class="name" id="vName"></span>
    <span class="desc" id="vDesc"></span>
    <span class="category" id="vCat"></span>
  </div>

  <nav class="visual-nav">
    <button class="nav-btn" id="prevBtn">&larr;</button>
    <div class="nav-dots" id="dots"></div>
    <button class="nav-btn" id="nextBtn">&rarr;</button>
  </nav>

  <p class="hint" id="hint">Use &larr; &rarr; arrow keys to explore</p>
</section>

<div class="divider"></div>

<section class="about">
  <h2>WHAT'S INSIDE</h2>
  <div class="stats">
    <div class="stat"><span class="number">54</span><span class="label">GAMES</span></div>
    <div class="stat"><span class="number">119</span><span class="label">VISUALS</span></div>
    <div class="stat"><span class="number">44</span><span class="label">AI DEMOS</span></div>
  </div>
  <p>
    A physical arcade cabinet powered by a Raspberry Pi and a
    64&times;64 RGB LED matrix. Each pixel is a real LED &mdash;
    warm, glowing, nostalgic, delightful.
  </p>
</section>

<div class="divider"></div>

<section class="collection">
  <h2>THE COLLECTION</h2>
  <div class="cat-grid">
    <span class="cat-tag" style="color:#ffff00">ARCADE (18)</span>
    <span class="cat-tag" style="color:#6496ff">SCIENCE (28)</span>
    <span class="cat-tag" style="color:#b464ff">MECHANICS (18)</span>
    <span class="cat-tag" style="color:#ff64ff">AUTOMATA (11)</span>
    <span class="cat-tag" style="color:#64ffff">DIGITAL (13)</span>
    <span class="cat-tag" style="color:#ffb432">MUSIC (11)</span>
    <span class="cat-tag" style="color:#ffa000">ROAD+RAIL (8)</span>
    <span class="cat-tag" style="color:#64ff64">OUTDOORS (7)</span>
    <span class="cat-tag" style="color:#ff6464">AI DEMOS (44)</span>
    <span class="cat-tag" style="color:#ffff00">ART (5)</span>
    <span class="cat-tag" style="color:#ff8080">HOUSEHOLD (5)</span>
    <span class="cat-tag" style="color:#80ff00">SPRITES (9)</span>
    <span class="cat-tag" style="color:#00ff00">RETRO (6)</span>
    <span class="cat-tag" style="color:#ff0000">SUPERHEROES (4)</span>
  </div>
</section>

<footer>
  Programmed with AI, Designed & Curated by Hand
</footer>

<script src="shared.js"></script>
<script>
// =============================================================
// VISUALS
// =============================================================

// ----- Fire -----
class Fire {
  constructor(display) {
    this.display = display;
    this.name = 'FIRE';
    this.desc = 'Classic fire simulation';
    this.category = 'OUTDOORS';
  }
  reset() {
    this.heat = [];
    for (let y = 0; y < GRID; y++) this.heat[y] = new Float32Array(GRID);
  }
  update(dt) {
    // Heat source at bottom
    for (let x = 0; x < GRID; x++) {
      this.heat[GRID-1][x] = Math.random() < 0.75
        ? 160 + Math.random() * 95
        : Math.random() * 100;
    }
    // Propagate upward
    for (let y = GRID - 2; y >= 0; y--) {
      for (let x = 0; x < GRID; x++) {
        const below = this.heat[y+1][x];
        const left  = this.heat[y+1][Math.max(0, x-1)];
        const right = this.heat[y+1][Math.min(GRID-1, x+1)];
        const avg = (below * 3 + left + right) / 5;
        this.heat[y][x] = Math.max(0, avg - Math.random() * 4);
      }
    }
  }
  draw() {
    this.display.clear(0, 0, 0);
    for (let y = 0; y < GRID; y++) {
      for (let x = 0; x < GRID; x++) {
        const v = this.heat[y][x] / 255;
        if (v > 0.01) {
          let r, g, b;
          if (v < 0.25)      { const t=v/0.25;         r=128*t; g=0; b=0; }
          else if (v < 0.5)  { const t=(v-0.25)/0.25;  r=128+127*t; g=64*t; b=0; }
          else if (v < 0.75) { const t=(v-0.5)/0.25;   r=255; g=64+128*t; b=0; }
          else               { const t=(v-0.75)/0.25;  r=255; g=192+63*t; b=255*t; }
          this.display.setPixel(x, y, [r, g, b]);
        }
      }
    }
  }
}

// ----- Matrix -----
class MatrixRain {
  constructor(display) {
    this.display = display;
    this.name = 'MATRIX';
    this.desc = 'Falling digital rain';
    this.category = 'DIGITAL';
  }
  reset() {
    this.time = 0;
    this.drops = [];
    for (let x = 0; x < GRID; x++) {
      for (let n = 0; n < (Math.random() < 0.4 ? 2 : 1); n++) {
        this.drops.push(this._makeDrop(x, true));
      }
    }
  }
  _makeDrop(x, scatter) {
    return {
      x,
      y: scatter ? (Math.random() * GRID * 3 - GRID * 2) : -(Math.random() * 20 + 1),
      speed: 15 + Math.random() * 20,
      length: 5 + Math.floor(Math.random() * 11),
    };
  }
  update(dt) {
    this.time += dt;
    for (const d of this.drops) {
      d.y += d.speed * dt;
      if (d.y - d.length > GRID) Object.assign(d, this._makeDrop(d.x, false));
    }
  }
  draw() {
    this.display.clear(0, 0, 0);
    for (const d of this.drops) {
      const hy = d.y | 0;
      for (let i = 0; i < d.length; i++) {
        const y = hy - i;
        if (y >= 0 && y < GRID) {
          if (i === 0) {
            this.display.setPixel(d.x, y, [200, 255, 200]);
          } else {
            const fade = 1 - i / d.length;
            const br = 200 * fade * fade | 0;
            this.display.setPixel(d.x, y, [0, br, br * 0.4 | 0]);
          }
        }
      }
    }
  }
}

// ----- Plasma -----
class Plasma {
  constructor(display) {
    this.display = display;
    this.name = 'PLASMA';
    this.desc = 'Sine wave interference patterns';
    this.category = 'DIGITAL';
  }
  reset() { this.time = 0; }
  update(dt) { this.time += dt; }
  draw() {
    this.display.clear(0, 0, 0);
    const t = this.time;
    for (let y = 0; y < GRID; y++) {
      for (let x = 0; x < GRID; x++) {
        const v1 = Math.sin(x * 0.1 + t);
        const v2 = Math.sin(y * 0.1 + t * 0.7);
        const v3 = Math.sin((x + y) * 0.1 + t * 0.5);
        const v4 = Math.sin(Math.sqrt((x-32)**2 + (y-32)**2) * 0.15 - t);
        let v = (v1 + v2 + v3 + v4 + 4) / 8; // 0..1
        // Rainbow palette
        const h = v * 6;
        const hi = h | 0, f = h - hi;
        let r, g, b;
        switch (hi) {
          case 0: r=255; g=255*f|0; b=0; break;
          case 1: r=255*(1-f)|0; g=255; b=0; break;
          case 2: r=0; g=255; b=255*f|0; break;
          case 3: r=0; g=255*(1-f)|0; b=255; break;
          case 4: r=255*f|0; g=0; b=255; break;
          default: r=255; g=0; b=255*(1-f)|0; break;
        }
        this.display.setPixel(x, y, [r, g, b]);
      }
    }
  }
}

// ----- Starfield -----
class Starfield {
  constructor(display) {
    this.display = display;
    this.name = 'STARFIELD';
    this.desc = '3D star tunnel';
    this.category = 'OUTDOORS';
  }
  reset() {
    this.time = 0;
    this.stars = [];
    for (let i = 0; i < 120; i++) this.stars.push(this._makeStar());
  }
  _makeStar() {
    const a = Math.random() * Math.PI * 2;
    const d = Math.random() * 0.9 + 0.1;
    return { x: Math.cos(a)*d, y: Math.sin(a)*d, z: Math.random()*0.5 + 0.5 };
  }
  update(dt) {
    this.time += dt;
    for (const s of this.stars) {
      s.z -= 0.5 * dt;
      if (s.z <= 0.01) { Object.assign(s, this._makeStar()); s.z = 1; }
    }
  }
  draw() {
    this.display.clear(0, 0, 0);
    const cx = GRID / 2, cy = GRID / 2;
    // Sort far to near
    this.stars.sort((a, b) => b.z - a.z);
    for (const s of this.stars) {
      if (s.z > 0.01) {
        const sx = cx + (s.x / s.z) * cx | 0;
        const sy = cy + (s.y / s.z) * cy | 0;
        let br = Math.max(50, Math.min(255, 255 * (1 - s.z) | 0));
        if (sx >= 0 && sx < GRID && sy >= 0 && sy < GRID) {
          // Warp trails
          const color = [br, br, br * 0.9 | 0];
          const pz = s.z + 0.05;
          const px = cx + (s.x / pz) * cx | 0;
          const py = cy + (s.y / pz) * cy | 0;
          this.display.drawLine(px, py, sx, sy, color);
          if (s.z < 0.25) {
            this.display.setPixel(sx+1, sy, color);
            this.display.setPixel(sx, sy+1, color);
          }
        }
      }
    }
  }
}

// ----- Boids -----
class Boids {
  constructor(display) {
    this.display = display;
    this.name = 'BOIDS';
    this.desc = 'Emergent flocking behavior';
    this.category = 'AUTOMATA';
  }
  reset() {
    this.time = 0;
    this.boids = [];
    for (let i = 0; i < 55; i++) this._spawnRandom();
    this.spawnTimer = 0;
  }
  _spawnRandom() {
    const a = Math.random() * Math.PI * 2;
    const spd = 1.5 + Math.random();
    this.boids.push({
      x: 5 + Math.random() * (GRID - 10),
      y: 5 + Math.random() * (GRID - 10),
      vx: Math.cos(a) * spd,
      vy: Math.sin(a) * spd,
    });
  }
  _dist(a, b) {
    let dx = Math.abs(a.x - b.x), dy = Math.abs(a.y - b.y);
    if (dx > GRID/2) dx = GRID - dx;
    if (dy > GRID/2) dy = GRID - dy;
    return Math.sqrt(dx*dx + dy*dy);
  }
  _tdiff(from, to) {
    let d = to - from;
    if (d > GRID/2) d -= GRID;
    else if (d < -GRID/2) d += GRID;
    return d;
  }
  update(dt) {
    this.time += dt;
    this.spawnTimer += dt;
    if (this.spawnTimer > 0.2) { this.spawnTimer = 0; this._spawnRandom(); }

    const PR = 10, SR = 2.5;
    const newV = [];
    for (const b of this.boids) {
      let sepX=0, sepY=0, aliX=0, aliY=0, cohX=0, cohY=0, nc=0;
      for (const o of this.boids) {
        if (o === b) continue;
        const d = this._dist(b, o);
        if (d < PR) {
          nc++;
          aliX += o.vx; aliY += o.vy;
          cohX += this._tdiff(b.x, o.x); cohY += this._tdiff(b.y, o.y);
          if (d < SR && d > 0) {
            const w = 1/d;
            sepX += this._tdiff(o.x, b.x) * w;
            sepY += this._tdiff(o.y, b.y) * w;
          }
        }
      }
      let ax = sepX * 1.8, ay = sepY * 1.8;
      if (nc > 0) {
        ax += (aliX/nc - b.vx) * 1.5;
        ay += (aliY/nc - b.vy) * 1.5;
        ax += (cohX/nc) * 1.8;
        ay += (cohY/nc) * 1.8;
      }
      newV.push([b.vx + ax * dt, b.vy + ay * dt]);
    }
    for (let i = 0; i < this.boids.length; i++) {
      const b = this.boids[i];
      b.vx = newV[i][0]; b.vy = newV[i][1];
      // Limit speed
      const spd = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
      if (spd > 3) { b.vx = b.vx/spd*3; b.vy = b.vy/spd*3; }
      else if (spd < 0.5 && spd > 0) { b.vx = b.vx/spd*0.5; b.vy = b.vy/spd*0.5; }
      b.x += b.vx * dt; b.y += b.vy * dt;
      // Soft boundary
      const m = 6, tf = 0.15;
      if (b.x < m) b.vx += tf; else if (b.x > GRID-m) b.vx -= tf;
      if (b.y < m) b.vy += tf; else if (b.y > GRID-m) b.vy -= tf;
    }
    // Remove off-screen, cap population
    this.boids = this.boids.filter(b => b.x > -3 && b.x < GRID+3 && b.y > -3 && b.y < GRID+3);
    if (this.boids.length > 90) this.boids = this.boids.slice(-60);
  }
  _headingColor(vx, vy) {
    const h = ((Math.atan2(vy, vx) + Math.PI) / (Math.PI * 2)) * 6;
    const i = h | 0, f = h - i;
    let r, g, b;
    switch (i) {
      case 0: r=1; g=f; b=0; break;
      case 1: r=1-f; g=1; b=0; break;
      case 2: r=0; g=1; b=f; break;
      case 3: r=0; g=1-f; b=1; break;
      case 4: r=f; g=0; b=1; break;
      default: r=1; g=0; b=1-f; break;
    }
    return [r*255|0, g*255|0, b*255|0];
  }
  draw() {
    this.display.clear(0, 0, 0);
    for (const b of this.boids) {
      const px = b.x | 0, py = b.y | 0;
      const c = this._headingColor(b.vx, b.vy);
      for (let dy = 0; dy < 2; dy++)
        for (let dx = 0; dx < 2; dx++)
          this.display.setPixel(px+dx, py+dy, c);
      // Trail
      const spd = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
      if (spd > 0.1) {
        const tdx = -b.vx/spd, tdy = -b.vy/spd;
        for (let i = 1; i < 4; i++) {
          const fade = 1 - i/4;
          this.display.setPixel(
            px + tdx*i*1.2 | 0, py + tdy*i*1.2 | 0,
            [c[0]*fade*0.5|0, c[1]*fade*0.5|0, c[2]*fade*0.5|0]
          );
        }
      }
    }
  }
}

// ----- Life -----
class Life {
  constructor(display) {
    this.display = display;
    this.name = 'LIFE';
    this.desc = "Conway's cellular automaton";
    this.category = 'AUTOMATA';
  }
  reset() {
    this.time = 0;
    this.stepTimer = 0;
    this.grid = [];
    for (let y = 0; y < GRID; y++) {
      this.grid[y] = new Uint8Array(GRID);
      for (let x = 0; x < GRID; x++)
        this.grid[y][x] = Math.random() < 0.3 ? 1 : 0;
    }
  }
  _countNeighbors(x, y) {
    let c = 0;
    for (let dy = -1; dy <= 1; dy++)
      for (let dx = -1; dx <= 1; dx++) {
        if (!dx && !dy) continue;
        if (this.grid[(y+dy+GRID)%GRID][(x+dx+GRID)%GRID]) c++;
      }
    return c;
  }
  update(dt) {
    this.time += dt;
    this.stepTimer += dt;
    if (this.stepTimer < 0.1) return;
    this.stepTimer = 0;
    const next = [];
    for (let y = 0; y < GRID; y++) {
      next[y] = new Uint8Array(GRID);
      for (let x = 0; x < GRID; x++) {
        const n = this._countNeighbors(x, y);
        next[y][x] = this.grid[y][x] ? (n===2||n===3 ? 1 : 0) : (n===3 ? 1 : 0);
      }
    }
    this.grid = next;
    // Auto-reseed if population dies
    let pop = 0;
    for (let y = 0; y < GRID; y++) for (let x = 0; x < GRID; x++) pop += this.grid[y][x];
    if (pop < 10) this.reset();
  }
  draw() {
    this.display.clear(0, 0, 0);
    // Slowly shifting hue
    const hue = (this.time * 0.05) % 1;
    const h = hue * 6, hi = h | 0, f = h - hi;
    let r, g, b;
    switch (hi) {
      case 0: r=255; g=255*f|0; b=0; break;
      case 1: r=255*(1-f)|0; g=255; b=0; break;
      case 2: r=0; g=255; b=255*f|0; break;
      case 3: r=0; g=255*(1-f)|0; b=255; break;
      case 4: r=255*f|0; g=0; b=255; break;
      default: r=255; g=0; b=255*(1-f)|0; break;
    }
    const color = [r, g, b];
    for (let y = 0; y < GRID; y++)
      for (let x = 0; x < GRID; x++)
        if (this.grid[y][x]) this.display.setPixel(x, y, color);
  }
}

// ----- DVD Bounce -----
const DVD_COLORS = [
  [255,0,0],[255,127,0],[255,255,0],[0,255,0],
  [0,255,255],[0,127,255],[127,0,255],[255,0,255],[255,0,127],
];
class DVD {
  constructor(display) {
    this.display = display;
    this.name = 'DVD';
    this.desc = 'The iconic bouncing screensaver';
    this.category = 'HOUSEHOLD';
  }
  reset() {
    this.W = 12; this.H = 8;
    this.x = Math.random() * (GRID - this.W);
    this.y = Math.random() * (GRID - this.H);
    this.dx = Math.random() < 0.5 ? -1 : 1;
    this.dy = Math.random() < 0.5 ? -1 : 1;
    this.speed = 25;
    this.ci = Math.floor(Math.random() * DVD_COLORS.length);
    this.flash = 0;
  }
  update(dt) {
    if (this.flash > 0) this.flash -= dt * 3;
    this.x += this.dx * this.speed * dt;
    this.y += this.dy * this.speed * dt;
    let hitX = false, hitY = false;
    if (this.x <= 0)            { this.x = 0; this.dx = 1; hitX = true; }
    if (this.x >= GRID - this.W) { this.x = GRID - this.W; this.dx = -1; hitX = true; }
    if (this.y <= 0)            { this.y = 0; this.dy = 1; hitY = true; }
    if (this.y >= GRID - this.H) { this.y = GRID - this.H; this.dy = -1; hitY = true; }
    if (hitX || hitY) this.ci = (this.ci + 1) % DVD_COLORS.length;
    if (hitX && hitY) this.flash = 1;
  }
  draw() {
    if (this.flash > 0) {
      const f = this.flash * 255 | 0;
      this.display.clear(f, f, f);
    } else {
      this.display.clear(0, 0, 0);
    }
    const c = DVD_COLORS[this.ci];
    const ix = this.x | 0, iy = this.y | 0;
    for (let py = 0; py < this.H; py++)
      for (let px = 0; px < this.W; px++)
        this.display.setPixel(ix + px, iy + py, c);
  }
}


// ----- Turing (Gray-Scott Reaction-Diffusion) -----
const TURING_PAL = [[5,10,40],[10,40,120],[20,100,180],[80,200,220],[200,255,255],[255,255,255]];
class Turing {
  constructor(display) {
    this.display = display;
    this.name = 'TURING';
    this.desc = 'Reaction-diffusion spots';
    this.category = 'SCIENCE';
  }
  reset() {
    this.time = 0;
    const N = GRID * GRID;
    this.u = new Float64Array(N).fill(1);
    this.v = new Float64Array(N);
    this.uN = new Float64Array(N);
    this.vN = new Float64Array(N);
    this.f = 0.035; this.k = 0.065;
    // Seed patches of v
    for (let s = 0; s < 5; s++) {
      const cx = 5 + Math.random() * 54 | 0;
      const cy = 5 + Math.random() * 54 | 0;
      const r = 2 + Math.random() * 2;
      for (let dy = -4; dy <= 4; dy++)
        for (let dx = -4; dx <= 4; dx++)
          if (dx*dx+dy*dy <= r*r) {
            const i = ((cy+dy+GRID)%GRID)*GRID + (cx+dx+GRID)%GRID;
            this.v[i] = 0.5 + (Math.random()-0.5)*0.1;
            this.u[i] = 0.5 + (Math.random()-0.5)*0.1;
          }
    }
  }
  update(dt) {
    this.time += dt;
    const {u, v, uN, vN, f, k} = this;
    for (let step = 0; step < 8; step++) {
      for (let y = 0; y < GRID; y++) {
        for (let x = 0; x < GRID; x++) {
          const i = y*GRID+x;
          const up=((y-1+GRID)%GRID)*GRID+x, dn=((y+1)%GRID)*GRID+x;
          const lt=y*GRID+(x-1+GRID)%GRID, rt=y*GRID+(x+1)%GRID;
          const lapU = u[up]+u[dn]+u[lt]+u[rt]-4*u[i];
          const lapV = v[up]+v[dn]+v[lt]+v[rt]-4*v[i];
          const uvv = u[i]*v[i]*v[i];
          uN[i] = u[i] + 0.16*lapU - uvv + f*(1-u[i]);
          vN[i] = v[i] + 0.08*lapV + uvv - (f+k)*v[i];
        }
      }
      // Swap buffers
      const tu = new Float64Array(u); u.set(uN); uN.set(tu);
      const tv = new Float64Array(v); v.set(vN); vN.set(tv);
    }
    this.u = u; this.v = v;
  }
  draw() {
    const pal = TURING_PAL, nC = pal.length;
    for (let y = 0; y < GRID; y++) {
      for (let x = 0; x < GRID; x++) {
        const val = Math.max(0, Math.min(1, this.v[y*GRID+x]));
        const fi = val * (nC - 1);
        const lo = Math.min(fi | 0, nC - 2), hi = lo + 1;
        const t = fi - lo;
        this.display.setPixel(x, y, [
          pal[lo][0]+(pal[hi][0]-pal[lo][0])*t|0,
          pal[lo][1]+(pal[hi][1]-pal[lo][1])*t|0,
          pal[lo][2]+(pal[hi][2]-pal[lo][2])*t|0,
        ]);
      }
    }
  }
}

// ----- Hodge (Hodgepodge Machine) -----
class Hodge {
  constructor(display) {
    this.display = display;
    this.name = 'HODGE';
    this.desc = 'Belousov-Zhabotinsky spiral waves';
    this.category = 'AUTOMATA';
  }
  reset() {
    this.time = 0; this.stepTimer = 0;
    this.n = 63; this.k1 = 2; this.k2 = 3; this.g = 5;
    this.grid = new Uint8Array(GRID*GRID);
    this.next = new Uint8Array(GRID*GRID);
    for (let i = 0; i < GRID*GRID; i++)
      this.grid[i] = Math.random() < 0.2 ? Math.random()*this.n|0 : 0;
    // Build gradient palette
    const keys = [[20,0,80],[0,100,200],[0,200,150],[100,255,100],[255,255,0],[255,100,0],[150,0,100]];
    this.colors = [];
    const nC = this.n + 1, segs = keys.length - 1, per = nC / segs;
    for (let i = 0; i < nC; i++) {
      const seg = Math.min(i / per | 0, segs - 1);
      const t = (i - seg * per) / per;
      this.colors.push([
        keys[seg][0]+(keys[seg+1][0]-keys[seg][0])*t|0,
        keys[seg][1]+(keys[seg+1][1]-keys[seg][1])*t|0,
        keys[seg][2]+(keys[seg+1][2]-keys[seg][2])*t|0,
      ]);
    }
  }
  update(dt) {
    this.time += dt; this.stepTimer += dt;
    if (this.stepTimer < 0.1) return;
    this.stepTimer = 0;
    const {grid, next, n, k1, k2, g} = this;
    let alive = false;
    for (let y = 0; y < GRID; y++) {
      for (let x = 0; x < GRID; x++) {
        const i = y*GRID+x, state = grid[i];
        let infected = 0, ill = 0, total = state;
        for (let dy = -1; dy <= 1; dy++)
          for (let dx = -1; dx <= 1; dx++) {
            if (!dx && !dy) continue;
            const ni = ((y+dy+GRID)%GRID)*GRID + (x+dx+GRID)%GRID;
            const ns = grid[ni]; total += ns;
            if (ns === n) ill++; else if (ns > 0) infected++;
          }
        if (state === 0) next[i] = Math.min((infected/k1|0) + (ill/k2|0), n);
        else if (state === n) next[i] = 0;
        else next[i] = Math.min((total/9|0) + g, n);
        if (next[i] > 0) alive = true;
      }
    }
    grid.set(next);
    if (!alive) this.reset();
  }
  draw() {
    for (let y = 0; y < GRID; y++)
      for (let x = 0; x < GRID; x++)
        this.display.setPixel(x, y, this.colors[this.grid[y*GRID+x]]);
  }
}

// ----- Double Pendulum -----
const PEND_PAL = [[255,60,0],[255,160,0],[255,255,40],[255,80,0]];
class DblPendulum {
  constructor(display) {
    this.display = display;
    this.name = 'DBL PENDULUM';
    this.desc = 'Chaotic double pendulum';
    this.category = 'SCIENCE';
  }
  reset() {
    this.time = 0;
    this.L1 = 1; this.L2 = 1; this.m1 = 1; this.m2 = 1;
    this.a1 = Math.PI*0.75 + (Math.random()-0.5)*0.6;
    this.a2 = Math.PI*0.5 + (Math.random()-0.5)*0.6;
    this.w1 = 0; this.w2 = 0;
    this.S = 13; // scale
    this.px = 32; this.py = 64 - 2 - 3 - 13*2 | 0;
    this.trail = []; this.maxTrail = 500;
  }
  _deriv(a1, a2, w1, w2) {
    const g=9.81, m1=this.m1, m2=this.m2, L1=this.L1, L2=this.L2;
    const da=a1-a2, sd=Math.sin(da), cd=Math.cos(da), M=m1+m2;
    let den = 2*M - m2*(1+Math.cos(2*da));
    if (Math.abs(den)<1e-10) den=1e-10;
    const al1=(-g*M*Math.sin(a1)-m2*g*Math.sin(a1-2*a2)
      -2*m2*sd*(w2*w2*L2+w1*w1*L1*cd))/(L1*den);
    const al2=(2*sd*(w1*w1*L1*M+g*M*Math.cos(a1)
      +w2*w2*L2*m2*cd))/(L2*den);
    return [al1, al2];
  }
  update(dt) {
    this.time += dt;
    const steps = 10, h = dt / steps;
    for (let s = 0; s < steps; s++) {
      let {a1,a2,w1,w2} = this;
      const [dw11,dw21]=this._deriv(a1,a2,w1,w2);
      const [dw12,dw22]=this._deriv(a1+w1*h/2,a2+w2*h/2,w1+dw11*h/2,w2+dw21*h/2);
      const [dw13,dw23]=this._deriv(a1+(w1+dw11*h/2)*h/2,a2+(w2+dw21*h/2)*h/2,w1+dw12*h/2,w2+dw22*h/2);
      const [dw14,dw24]=this._deriv(a1+(w1+dw12*h/2)*h,a2+(w2+dw22*h/2)*h,w1+dw13*h,w2+dw23*h);
      this.a1+=h*(w1+(w1+dw11*h/2)*2+(w1+dw12*h/2)*2+(w1+dw13*h))/6;
      this.a2+=h*(w2+(w2+dw21*h/2)*2+(w2+dw22*h/2)*2+(w2+dw23*h))/6;
      this.w1+=h*(dw11+2*dw12+2*dw13+dw14)/6;
      this.w2+=h*(dw21+2*dw22+2*dw23+dw24)/6;
    }
    const x1=this.px+this.S*Math.sin(this.a1);
    const y1=this.py+this.S*Math.cos(this.a1);
    const x2=x1+this.S*Math.sin(this.a2);
    const y2=y1+this.S*Math.cos(this.a2);
    this.trail.push([Math.round(x2),Math.round(y2)]);
    if (this.trail.length>this.maxTrail) this.trail.shift();
  }
  draw() {
    this.display.clear(0,0,0);
    const pal=PEND_PAL, total=this.trail.length;
    for (let i=0;i<total;i++) {
      const [tx,ty]=this.trail[i];
      if (tx>=0&&tx<GRID&&ty>=0&&ty<GRID) {
        const t=i/(total-1||1);
        const pi=t*(pal.length-1), lo=pi|0, hi=Math.min(lo+1,pal.length-1), f=pi-lo;
        const br=0.15+0.85*t;
        this.display.setPixel(tx,ty,[
          (pal[lo][0]+(pal[hi][0]-pal[lo][0])*f)*br|0,
          (pal[lo][1]+(pal[hi][1]-pal[lo][1])*f)*br|0,
          (pal[lo][2]+(pal[hi][2]-pal[lo][2])*f)*br|0,
        ]);
      }
    }
    const x1=this.px+this.S*Math.sin(this.a1)|0;
    const y1=this.py+this.S*Math.cos(this.a1)|0;
    const x2=x1+this.S*Math.sin(this.a2)|0;
    const y2=y1+this.S*Math.cos(this.a2)|0;
    this.display.drawLine(this.px,this.py,x1,y1,[160,160,170]);
    this.display.drawLine(x1,y1,x2,y2,[160,160,170]);
    this.display.setPixel(this.px,this.py,[255,255,255]);
    this.display.drawCircle(x1,y1,2,[200,200,210],true);
    this.display.drawCircle(x2,y2,3,PEND_PAL[0],true);
  }
}

// ----- 3-Body Orbits -----
const ORBIT_PAL = [[255,50,100],[50,255,150],[100,100,255],[255,255,50],[255,100,255],[50,255,255]];
class Orbits3Body {
  constructor(display) {
    this.display = display;
    this.name = '3 BODY';
    this.desc = 'Gravitational dance';
    this.category = 'SCIENCE';
  }
  reset() {
    this.time = 0; this.bodies = [];
    const cx=GRID/2, cy=GRID/2;
    for (let i=0;i<3;i++) {
      const a=2*Math.PI*i/3+(Math.random()-0.5)*0.4;
      const r=18;
      const v=Math.sqrt(800*10*2/(2*r+2))*0.65;
      this.bodies.push({
        x:cx+r*Math.cos(a), y:cy+r*Math.sin(a),
        vx:-v*Math.sin(a)+(Math.random()-0.5), vy:v*Math.cos(a)+(Math.random()-0.5),
        ax:0, ay:0, mass:10, radius:3, ci:i,
        trail: [],
      });
    }
  }
  update(dt) {
    this.time += dt;
    const G=800, SOFT2=25, h=0.0005, steps=8;
    const b=this.bodies;
    for (let s=0;s<steps;s++) {
      // Compute accelerations
      for (const bi of b) { bi.ax=0; bi.ay=0; }
      for (let i=0;i<b.length;i++)
        for (let j=i+1;j<b.length;j++) {
          const dx=b[j].x-b[i].x, dy=b[j].y-b[i].y;
          const d2=dx*dx+dy*dy+SOFT2;
          const inv=1/Math.sqrt(d2), inv3=inv*inv*inv, f=G*inv3;
          b[i].ax+=f*dx*b[j].mass; b[i].ay+=f*dy*b[j].mass;
          b[j].ax-=f*dx*b[i].mass; b[j].ay-=f*dy*b[i].mass;
        }
      // Verlet step
      for (const bi of b) {
        bi.vx+=0.5*h*bi.ax; bi.vy+=0.5*h*bi.ay;
        bi.x+=h*bi.vx; bi.y+=h*bi.vy;
      }
      // Recompute accelerations
      for (const bi of b) { bi.ax=0; bi.ay=0; }
      for (let i=0;i<b.length;i++)
        for (let j=i+1;j<b.length;j++) {
          const dx=b[j].x-b[i].x, dy=b[j].y-b[i].y;
          const d2=dx*dx+dy*dy+SOFT2;
          const inv=1/Math.sqrt(d2), inv3=inv*inv*inv, f=G*inv3;
          b[i].ax+=f*dx*b[j].mass; b[i].ay+=f*dy*b[j].mass;
          b[j].ax-=f*dx*b[i].mass; b[j].ay-=f*dy*b[i].mass;
        }
      for (const bi of b) { bi.vx+=0.5*h*bi.ax; bi.vy+=0.5*h*bi.ay; }
    }
    // Edge force + trails
    const margin=12, strength=80;
    for (const bi of b) {
      let t=0;
      if (bi.x<margin) t=Math.max(t,(margin-bi.x)/margin);
      else if (bi.x>GRID-margin) t=Math.max(t,(bi.x-(GRID-margin))/margin);
      if (bi.y<margin) t=Math.max(t,(margin-bi.y)/margin);
      else if (bi.y>GRID-margin) t=Math.max(t,(bi.y-(GRID-margin))/margin);
      if (t>0) {
        const dx=GRID/2-bi.x, dy=GRID/2-bi.y;
        const d=Math.sqrt(dx*dx+dy*dy)+0.1, f=strength*t*t*0.0005;
        bi.vx+=dx/d*f; bi.vy+=dy/d*f;
      }
      bi.trail.push([bi.x,bi.y]);
      if (bi.trail.length>120) bi.trail.shift();
    }
    if (b.length<2) this.reset();
  }
  draw() {
    this.display.clear(0,0,0);
    for (const bi of this.bodies) {
      const c=ORBIT_PAL[bi.ci%ORBIT_PAL.length];
      const tl=bi.trail.length;
      for (let i=0;i<tl;i++) {
        const [tx,ty]=bi.trail[i];
        const ix=tx|0, iy=ty|0;
        if (ix>=0&&ix<GRID&&iy>=0&&iy<GRID) {
          const t=(i+1)/tl;
          this.display.setPixel(ix,iy,[c[0]*t*0.4|0,c[1]*t*0.4|0,c[2]*t*0.4|0]);
        }
      }
      const ix=bi.x|0, iy=bi.y|0;
      this.display.drawCircle(ix,iy,bi.radius,c,true);
      if (ix>=0&&ix<GRID&&iy>=0&&iy<GRID)
        this.display.setPixel(ix,iy,[Math.min(255,c[0]+80),Math.min(255,c[1]+80),Math.min(255,c[2]+80)]);
    }
  }
}


// ----- Breakout (playable game!) -----
class BreakoutGame {
  constructor(display) {
    this.display = display;
    this.isGame = true;
  }
  reset() {
    this.state = 'waiting'; // waiting -> playing -> gameover
    this.score = 0; this.lives = 3; this.hitCount = 0;
    this.hitCeiling = false;
    this.paddleWidth = 12;
    this.paddleX = 4 + (56 - 12) / 2;
    this.paddleY = 60;
    this.ballX = 32; this.ballY = 58;
    this.ballDX = 0; this.ballDY = 0;
    this.ballSpeed = 40; this.ballLaunched = false;
    this.bricks = []; this.setupBricks();
    this.gameOverTimer = 0;
    this.flashTimer = 0;
  }
  setupBricks() {
    const rows = [
      {color:[255,255,0],pts:1},{color:[255,255,0],pts:1},
      {color:[0,200,0],pts:3},{color:[0,200,0],pts:3},
      {color:[255,128,0],pts:5},{color:[255,128,0],pts:5},
      {color:[255,0,0],pts:7},{color:[255,0,0],pts:7},
    ];
    for (let row = 0; row < 8; row++)
      for (let col = 0; col < 14; col++)
        this.bricks.push({
          x: 4+col*4, y: 8+(7-row)*3,
          w: 3, h: 2, color: rows[row].color, pts: rows[row].pts,
        });
  }
  launch() {
    if (!this.ballLaunched) {
      const angle = (Math.random()-0.5)*0.8;
      this.ballDX = Math.sin(angle)*this.ballSpeed;
      this.ballDY = -this.ballSpeed;
      this.ballLaunched = true;
      this.hitCount = 0;
    }
  }
  update(input, dt) {
    if (this.state === 'gameover') {
      this.gameOverTimer += dt;
      if (input.action_l) this.reset();
      return;
    }
    if (this.state === 'waiting') {
      if (input.action_l) { this.state = 'playing'; this.launch(); }
      return;
    }
    // Paddle movement
    if (input.left) this.paddleX = Math.max(4, this.paddleX - 60*dt);
    if (input.right) this.paddleX = Math.min(60-this.paddleWidth, this.paddleX + 60*dt);
    // Launch
    if (input.action_l && !this.ballLaunched) this.launch();
    if (!this.ballLaunched) {
      this.ballX = this.paddleX + this.paddleWidth/2;
      this.ballY = this.paddleY - 2;
      return;
    }
    // Update flash
    if (this.flashTimer > 0) this.flashTimer -= dt;
    // Speed tiers
    if (this.hitCount >= 12) this.ballSpeed = 60;
    else if (this.hitCount >= 4) this.ballSpeed = 50;
    else this.ballSpeed = 40;
    if (this.ballY < 20) this.ballSpeed = Math.max(this.ballSpeed, 70);
    // Normalize velocity
    const cs = Math.sqrt(this.ballDX**2 + this.ballDY**2);
    if (cs > 0) { const s=this.ballSpeed/cs; this.ballDX*=s; this.ballDY*=s; }
    // Move ball
    this.ballX += this.ballDX*dt; this.ballY += this.ballDY*dt;
    // Wall collisions
    if (this.ballX <= 4) { this.ballX = 4; this.ballDX = Math.abs(this.ballDX); }
    if (this.ballX >= 58) { this.ballX = 58; this.ballDX = -Math.abs(this.ballDX); }
    // Ceiling
    if (this.ballY <= 7) {
      this.ballY = 7; this.ballDY = Math.abs(this.ballDY);
      if (!this.hitCeiling) { this.hitCeiling = true; this.paddleWidth = 6; }
    }
    // Bottom - lose life
    if (this.ballY >= 63) {
      this.lives--;
      this.ballLaunched = false; this.hitCount = 0;
      if (this.lives <= 0) { this.state = 'gameover'; this.gameOverTimer = 0; }
    }
    // Paddle collision
    const biy = this.ballY|0;
    if (this.ballDY > 0 && this.paddleY <= biy+1 && biy+1 <= this.paddleY+1 &&
        this.paddleX-1 <= this.ballX && this.ballX <= this.paddleX+this.paddleWidth) {
      const hit = (this.ballX - this.paddleX) / this.paddleWidth;
      const angle = (hit - 0.5) * 1.2;
      this.ballDX = Math.sin(angle)*this.ballSpeed;
      this.ballDY = -Math.abs(Math.cos(angle)*this.ballSpeed);
      this.ballY = this.paddleY - 2;
    }
    // Brick collisions
    const bx = this.ballX|0, by = this.ballY|0;
    for (let i = this.bricks.length-1; i >= 0; i--) {
      const b = this.bricks[i];
      let hit = false;
      for (let dx = 0; dx < 2 && !hit; dx++)
        for (let dy = 0; dy < 2 && !hit; dy++)
          if (bx+dx >= b.x && bx+dx <= b.x+b.w && by+dy >= b.y && by+dy <= b.y+b.h) hit = true;
      if (hit) {
        this.bricks.splice(i, 1);
        this.score += b.pts; this.hitCount++;
        this.flashTimer = 0.08;
        this.ballDY = -this.ballDY;
        break;
      }
    }
    if (this.bricks.length === 0) { this.state = 'gameover'; this.gameOverTimer = 0; }
  }
  draw() {
    this.display.clear(0,0,0);
    if (this.state === 'gameover') {
      if (this.bricks.length === 0) {
        this.display.drawTextSmall(8, 16, 'YOU WIN!', [255,255,0]);
      } else {
        this.display.drawTextSmall(8, 16, 'GAME OVER', [255,0,0]);
      }
      this.display.drawTextSmall(6, 28, `SCORE:${this.score}`, [255,255,255]);
      if (this.gameOverTimer > 1.5)
        this.display.drawTextSmall(6, 44, 'SPC:RETRY', [128,128,128]);
      return;
    }
    // Score
    this.display.drawTextSmall(1, 1, `${this.score}`, [255,255,255]);
    // Lives as 2x2 dots
    for (let i = 0; i < this.lives; i++) {
      this.display.setPixel(50+i*4, 2, [255,255,255]);
      this.display.setPixel(51+i*4, 2, [255,255,255]);
      this.display.setPixel(50+i*4, 3, [255,255,255]);
      this.display.setPixel(51+i*4, 3, [255,255,255]);
    }
    // Separator + walls
    this.display.drawLine(0, 6, 63, 6, [64,64,64]);
    this.display.drawRect(0, 7, 4, 57, [48,48,48]);
    this.display.drawRect(60, 7, 4, 57, [48,48,48]);
    // Bricks
    for (const b of this.bricks) {
      this.display.drawRect(b.x, b.y, b.w, b.h, b.color);
    }
    // Paddle
    const px = this.paddleX|0;
    for (let i = 0; i < this.paddleWidth; i++) {
      this.display.setPixel(px+i, this.paddleY, [255,255,255]);
      this.display.setPixel(px+i, this.paddleY+1, [128,128,128]);
    }
    // Ball (2x2)
    const bx = this.ballX|0, by = this.ballY|0;
    this.display.setPixel(bx,by,[255,255,255]); this.display.setPixel(bx+1,by,[255,255,255]);
    this.display.setPixel(bx,by+1,[255,255,255]); this.display.setPixel(bx+1,by+1,[255,255,255]);
    // Prompt
    if (this.state === 'waiting')
      this.display.drawTextSmall(6, 42, 'SPC:START', [128,128,128]);
    else if (!this.ballLaunched)
      this.display.drawTextSmall(4, 45, 'SPC:LAUNCH', [128,128,128]);
  }
}


// =============================================================
// SHOWCASE CONTROLLER
// =============================================================

const display = new Display();

// Input state for games
const inputState = { left:false, right:false, up:false, down:false, action_l:false };
let gameActive = false; // true when user is playing a game

const VISUALS = [
  () => new Fire(display),
  () => new MatrixRain(display),
  () => new Boids(display),
  () => new BreakoutGame(display),
  () => new Plasma(display),
  () => new Turing(display),
  () => new Starfield(display),
  () => new Life(display),
  () => new Hodge(display),
  () => new DblPendulum(display),
  () => new Orbits3Body(display),
  () => new DVD(display),
];

const LABELS = [
  { name: 'FIRE',        desc: 'Classic fire simulation',             cat: 'OUTDOORS' },
  { name: 'MATRIX',      desc: 'Falling digital rain',                cat: 'DIGITAL' },
  { name: 'BOIDS',       desc: 'Emergent flocking behavior',          cat: 'AUTOMATA' },
  { name: 'BREAKOUT',    desc: 'Classic 1976 Atari \u2014 playable!', cat: 'GAME' },
  { name: 'PLASMA',      desc: 'Sine wave interference patterns',     cat: 'DIGITAL' },
  { name: 'TURING',      desc: 'Gray-Scott reaction-diffusion',       cat: 'SCIENCE' },
  { name: 'STARFIELD',   desc: '3D perspective star tunnel',           cat: 'OUTDOORS' },
  { name: 'LIFE',        desc: "Conway's cellular automaton",          cat: 'AUTOMATA' },
  { name: 'HODGEPODGE',  desc: 'Spiral wave cellular automaton',      cat: 'AUTOMATA' },
  { name: 'PENDULUM',    desc: 'Chaotic double pendulum',             cat: 'SCIENCE' },
  { name: 'ORBITS',      desc: 'Three-body gravitational dance',      cat: 'SCIENCE' },
  { name: 'DVD',         desc: 'The iconic bouncing screensaver',      cat: 'HOUSEHOLD' },
];

let currentIndex = 0;
let currentVisual = null;
let autoCycleTimer = 0;
const AUTO_CYCLE_SEC = 10;
let autoCyclePaused = 0;
let transitioning = false;

// DOM elements
const ledCanvas  = document.getElementById('ledCanvas');
const glowCanvas = document.getElementById('glowCanvas');
const frame      = document.getElementById('frame');
const info       = document.getElementById('info');
const nameEl     = document.getElementById('vName');
const descEl     = document.getElementById('vDesc');
const catEl      = document.getElementById('vCat');
const dotsEl     = document.getElementById('dots');
const prevBtn    = document.getElementById('prevBtn');
const nextBtn    = document.getElementById('nextBtn');

const renderer = new LEDRenderer(ledCanvas, glowCanvas);

// Build dots
for (let i = 0; i < VISUALS.length; i++) {
  const dot = document.createElement('div');
  dot.className = 'dot' + (i === 0 ? ' active' : '');
  dot.addEventListener('click', () => switchTo(i));
  dotsEl.appendChild(dot);
}
const dots = dotsEl.querySelectorAll('.dot');

const hintEl = document.getElementById('hint');
function updateInfo(idx) {
  const l = LABELS[idx];
  nameEl.textContent = l.name;
  descEl.textContent = l.desc;
  catEl.textContent = l.cat;
  dots.forEach((d, i) => d.classList.toggle('active', i === idx));
  // Show game-specific hint
  if (l.cat === 'GAME') {
    hintEl.innerHTML = '\u2190 \u2192 move paddle &middot; SPACE launch &middot; click arrows to browse';
  } else {
    hintEl.innerHTML = 'Use &larr; &rarr; arrow keys to explore';
  }
}

function switchTo(idx) {
  if (transitioning || idx === currentIndex) return;
  transitioning = true;
  autoCyclePaused = 20; // pause auto-cycle after manual nav
  gameActive = false;
  inputState.left = inputState.right = inputState.up = inputState.down = inputState.action_l = false;

  // Fade out
  info.style.opacity = '0';
  ledCanvas.style.opacity = '0';
  glowCanvas.style.opacity = '0';

  setTimeout(() => {
    currentIndex = idx;
    currentVisual = VISUALS[idx]();
    currentVisual.reset();
    updateInfo(idx);
    autoCycleTimer = 0;

    // Fade in
    setTimeout(() => {
      info.style.opacity = '1';
      ledCanvas.style.opacity = '1';
      glowCanvas.style.opacity = '1';
      transitioning = false;
    }, 50);
  }, 180);
}

function nextVisual() { switchTo((currentIndex + 1) % VISUALS.length); }
function prevVisual() { switchTo((currentIndex - 1 + VISUALS.length) % VISUALS.length); }

// Navigation
prevBtn.addEventListener('click', prevVisual);
nextBtn.addEventListener('click', nextVisual);
document.addEventListener('keydown', (e) => {
  const isGame = currentVisual && currentVisual.isGame;
  if (isGame) {
    if (e.key === 'ArrowLeft')  { e.preventDefault(); inputState.left = true; }
    if (e.key === 'ArrowRight') { e.preventDefault(); inputState.right = true; }
    if (e.key === 'ArrowUp')    { e.preventDefault(); inputState.up = true; }
    if (e.key === 'ArrowDown')  { e.preventDefault(); inputState.down = true; }
    if (e.key === ' ' || e.key === 'z') { e.preventDefault(); inputState.action_l = true; gameActive = true; }
  } else {
    if (e.key === 'ArrowLeft')  { e.preventDefault(); prevVisual(); }
    if (e.key === 'ArrowRight') { e.preventDefault(); nextVisual(); }
  }
});
document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowLeft')  inputState.left = false;
  if (e.key === 'ArrowRight') inputState.right = false;
  if (e.key === 'ArrowUp')    inputState.up = false;
  if (e.key === 'ArrowDown')  inputState.down = false;
});

// Add CSS transitions to canvases
ledCanvas.style.transition = 'opacity 0.18s ease';
glowCanvas.style.transition = 'opacity 0.18s ease';
info.style.transition = 'opacity 0.15s ease';

// Ambient glow update
let lastGlowUpdate = 0;
function updateAmbientGlow(timestamp) {
  if (timestamp - lastGlowUpdate > 400) {
    lastGlowUpdate = timestamp;
    const [r, g, b] = renderer.getAverageColor(display);
    // Boost the glow a bit
    const br = Math.min(255, r * 1.5 | 0);
    const bg = Math.min(255, g * 1.5 | 0);
    const bb = Math.min(255, b * 1.5 | 0);
    frame.style.boxShadow =
      `0 0 80px rgba(${br},${bg},${bb},0.2), ` +
      `0 0 160px rgba(${br},${bg},${bb},0.08), ` +
      `0 8px 40px rgba(0,0,0,0.7)`;
  }
}

// ----- Main loop -----
let lastTime = 0;

function loop(timestamp) {
  const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
  lastTime = timestamp;

  if (currentVisual && !transitioning) {
    // Games get input state; visuals just get dt
    if (currentVisual.isGame) {
      currentVisual.update(inputState, dt);
      inputState.action_l = false; // single-press: clear after read
    } else {
      currentVisual.update(dt);
    }
    currentVisual.draw();
    renderer.render(display);
    updateAmbientGlow(timestamp);

    // Auto-cycle (paused during active gameplay)
    if (gameActive && currentVisual.isGame) {
      autoCycleTimer = 0;
    } else if (autoCyclePaused > 0) {
      autoCyclePaused -= dt;
    } else {
      autoCycleTimer += dt;
      if (autoCycleTimer >= AUTO_CYCLE_SEC) {
        autoCycleTimer = 0;
        nextVisual();
      }
    }
  }

  requestAnimationFrame(loop);
}

// ----- Start -----
currentVisual = VISUALS[0]();
currentVisual.reset();
updateInfo(0);
lastTime = performance.now();
requestAnimationFrame(loop);
</script>
</body>
</html>
